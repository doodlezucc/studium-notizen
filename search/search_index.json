{"config":{"lang":["de"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Einleitung","text":"<p>Gesammelte Notizen zu den Vorlesungen Informatik I (SoSe 22) und Informatik II (WiSe 22).</p> <p>Unter 2022 WS sind Themen des aktuellen Semesters zusammengefasst.</p>"},{"location":"2022%20SS/B%C3%A4ume/Balancierte%20B%C3%A4ume/","title":"Balancierte B\u00e4ume","text":""},{"location":"2022%20SS/B%C3%A4ume/Balancierte%20B%C3%A4ume/#eigenschaften","title":"Eigenschaften","text":"<ul> <li>Alle \u00c4ste (fast) gleich lang</li> <li>Kann in bin\u00e4ren Suchb\u00e4umen nicht erzwungen werden</li> <li>Nicht-balancierte B\u00e4ume nennt man entartete B\u00e4ume</li> </ul>"},{"location":"2022%20SS/B%C3%A4ume/Balancierte%20B%C3%A4ume/#rot-schwarz-baum","title":"Rot-Schwarz-Baum","text":"<ol> <li>Jeder Knoten ist entweder schwarz oder rot</li> <li>(Die Wurzel ist schwarz)</li> <li>Alle Bl\u00e4tter sind schwarz</li> <li>Die Kinder eines roten Knoten sind schwarz</li> <li> <p>Jeder Pfad von Knoten zu allen Bl\u00e4ttern enth\u00e4lt gleich viele schwarze Knoten</p> </li> <li> <p>Laufzeitkomplexit\u00e4t bei Einf\u00fcgen und L\u00f6schen h\u00f6her als bei bin\u00e4ren Suchb\u00e4umen</p> </li> <li>Suche ist f\u00fcr alle Eingabesequenzen garantiert <code>O(lg n)</code></li> </ol> <p>https://www.happycoders.eu/de/algorithmen/rot-schwarz-baum-java/</p>"},{"location":"2022%20SS/B%C3%A4ume/Balancierte%20B%C3%A4ume/#einfugen","title":"Einf\u00fcgen","text":"<ul> <li>Eingef\u00fcgte Knoten sind immer rot</li> <li>Falls Vater schwarz: fertig</li> <li>Falls Vater rot:<ul> <li>Umf\u00e4rben (Vater, Onkel, Gro\u00dfvater)</li> <li>Schleife: Hoch traversieren<ul> <li>Falls Onkel schwarz:<ul> <li>Falls rechtes Kind<ul> <li>Rotate-Left (Vater)</li> </ul> </li> <li>Falls linkes Kind<ul> <li>Rotate-Right (Gro\u00dfvater)</li> <li>Umf\u00e4rben (Vater, Gro\u00dfvater)</li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"2022%20SS/B%C3%A4ume/Balancierte%20B%C3%A4ume/#loschen","title":"L\u00f6schen","text":""},{"location":"2022%20SS/B%C3%A4ume/Balancierte%20B%C3%A4ume/#rotate","title":"Rotate","text":"<ul> <li>rotate-left<ul> <li>parent becomes left child</li> <li>left child becomes parent's right child</li> </ul> </li> <li>rotate-right<ul> <li>parent becomes right child</li> <li>right child becomes parent's left child</li> </ul> </li> </ul> <pre><code>  20                [40]                       40                [20]\n/  \\               /  \\                      /  \\               /  \\  10 [40]    --&gt;    20    50                  [20]  50    --&gt;    10    40\n/  \\          /  \\                       /  \\                    /  \\     30  50        10  30                     10  30                  30  50    </code></pre>"},{"location":"2022%20SS/B%C3%A4ume/Baum/","title":"Baum","text":""},{"location":"2022%20SS/B%C3%A4ume/Baum/#eigenschaften","title":"Eigenschaften","text":"<ul> <li>Zwischen zwei Knoten gibt es genau einen Weg</li> <li>Es gibt immer eine Kante weniger als Knoten</li> <li>Der Graph ist minimal zusammenh\u00e4ngend (?)</li> <li> <p>Keine Zyklen</p> </li> <li> <p>Entfernt man eine Kante, entstehen zwei Teilb\u00e4ume (Wald)</p> </li> <li>Verbindet man die Wurzeln zweier gerichteter B\u00e4ume, entsteht ein neuer Baum</li> </ul>"},{"location":"2022%20SS/B%C3%A4ume/Baum/#ungerichtete-baume","title":"Ungerichtete B\u00e4ume","text":"<ul> <li>Zusammenh\u00e4ngender, kreisfreier ungerichteter Graph</li> <li>Knoten mit Grad 1 hei\u00dfen Bl\u00e4tter</li> </ul>"},{"location":"2022%20SS/B%C3%A4ume/Baum/#gerichtete-baume","title":"Gerichtete B\u00e4ume","text":"<ul> <li>Gerichteter kreisfreier Graph</li> <li>Genau eine Wurzel mit Eingangsgrad 0</li> <li>Knoten mit Ausgangsgrad 0 hei\u00dfen Bl\u00e4tter</li> </ul>"},{"location":"2022%20SS/B%C3%A4ume/Baum/#wald","title":"Wald","text":"<ul> <li>Mehrere B\u00e4ume/Wurzeln</li> </ul>"},{"location":"2022%20SS/B%C3%A4ume/Baum/#hohetiefe-eines-baums","title":"H\u00f6he/Tiefe eines Baums","text":"<ul> <li>Leerer Baum hat keine Wurzel, H\u00f6he 0</li> <li>Wurzel hat Tiefe 0, H\u00f6he 1</li> </ul>"},{"location":"2022%20SS/B%C3%A4ume/Baum/#binarer-baum","title":"Bin\u00e4rer Baum","text":"<ul> <li>Ein leerer Baum</li> <li>Sind L und R zwei bin\u00e4re B\u00e4ume, lassen sie sich durch einen einzelnen Knoten zu einem neuen bin\u00e4ren Baum zusammenf\u00fcgen</li> </ul>"},{"location":"2022%20SS/B%C3%A4ume/Baum/#binarer-suchbaum","title":"Bin\u00e4rer Suchbaum","text":"<ul> <li>Beide Unterb\u00e4ume sind bin\u00e4re Suchb\u00e4ume</li> <li>Werte des linken Baums sind kleiner als Wurzelbeschriftung</li> <li>Werte des rechten Baums sind gr\u00f6\u00dfer als Wurzelbeschriftung</li> </ul>"},{"location":"2022%20SS/B%C3%A4ume/Baum/#voller-saturierter-baum","title":"Voller (saturierter) Baum","text":"<ul> <li>Jeder Knoten besitzt 0 oder 2 Kinder</li> </ul>"},{"location":"2022%20SS/B%C3%A4ume/Baum/#vollstandiger-baum","title":"Vollst\u00e4ndiger Baum","text":"<ul> <li>Alle Bl\u00e4tter haben dieselbe Tiefe</li> </ul>"},{"location":"2022%20SS/B%C3%A4ume/Baum/#vollstandiger-binarbaum-hohe-h","title":"Vollst\u00e4ndiger Bin\u00e4rbaum (H\u00f6he h)","text":"<ul> <li>\\(2^h-1\\) Knoten</li> <li>\\(2^{h-1} - 1\\) innere Knoten</li> <li>\\(2^t\\) Knoten in Tiefe t (\\(0 \\leq t \\leq h-1\\))</li> <li>\\(2^{h-1}\\) Bl\u00e4tter</li> </ul>"},{"location":"2022%20SS/B%C3%A4ume/Traversierung/","title":"Traversierung","text":""},{"location":"2022%20SS/B%C3%A4ume/Traversierung/#tiefensuche-depth-first","title":"Tiefensuche (depth-first)","text":"<ul> <li>Pre-order (Hauptreihenfolge): <code>W-l-r</code></li> <li>Post-order (Nebenreihenfolge): <code>l-r-W</code></li> <li>In-order (symmetrische Reihenfolge): <code>l-W-r</code></li> <li>Reverse in-order (anti-symmetrische Reihenfolge): <code>r-W-l</code></li> </ul>"},{"location":"2022%20SS/B%C3%A4ume/Traversierung/#breitensuche-breadth-first","title":"Breitensuche (breadth-first)","text":"<ul> <li>Jede Ebene des Baums wird von links nach rechts durchlaufen</li> <li>Algorithmus mittels Queue und wei\u00df/grau/schwarz-Markierung</li> </ul>"},{"location":"2022%20SS/Dynamische%20Speicherverwaltung/Pointer/","title":"Zeiger/Pointer","text":"<p>Alle Pointer haben dieselbe Gr\u00f6\u00dfe.</p>"},{"location":"2022%20SS/Dynamische%20Speicherverwaltung/Pointer/#heap-speicher-in-c","title":"Heap-Speicher in C","text":"<p>Speicher im Heap reservieren: <code>malloc(&lt;size in bytes&gt;)</code></p> <ul> <li>siehe sizeof</li> <li>return: Pointer auf Speicheraddresse</li> </ul> <p>Reservierten Speicher freigeben: <code>free(POINTER)</code></p> <pre><code>// Liegt auf Stack\nint a = 18;\n\n\n\n// Liegt auf Heap\nint *b = &amp;a; // *b == &amp;a == Pointer auf a\n\nint d = *b; // dereferenzieren\n\n// *&amp;a &lt;=&gt; a\n\n// NICHT m\u00f6glich, keine Addresse zugewiesen.\nint *f;\n*f = 7; int alpha(void) {...}\nint *ptr_a(void) = alpha\n\n\nstruct Punkt {\nint x;\nint y;\n}\n\nstruct Punkt* p = malloc(sizeof(struct Punkt));\nif (p == NULL) {\nreturn NULL;\n}\n\np-&gt;x = 1;\np-&gt;y = 2;\n\nfree(p)\n</code></pre>"},{"location":"2022%20SS/Dynamische%20Speicherverwaltung/Speicheraufbau/","title":"Speicheraufbau","text":""},{"location":"2022%20SS/Dynamische%20Speicherverwaltung/Speicheraufbau/#speicherbereiche","title":"Speicherbereiche","text":"<ul> <li>Code<ul> <li>Alle Anweisungen des Programms</li> </ul> </li> <li>Globale Variablen<ul> <li>Von \u00fcberall zugreifbar</li> </ul> </li> <li>Stack - managed memory<ul> <li>Funktionsvariablen</li> <li>R\u00fcckgabewerte</li> <li>R\u00fccksprungsaddressen</li> </ul> </li> <li>Heap - unmanaged memory<ul> <li>Gro\u00dfer Speicherbereich f\u00fcr Daten</li> <li>Daten sind nicht geordnet</li> <li>Gr\u00f6\u00dfe w\u00e4chst, wenn mehr Platz ben\u00f6tigt wird</li> </ul> </li> </ul>"},{"location":"2022%20SS/Dynamische%20Speicherverwaltung/sizeof/","title":"sizeof","text":""},{"location":"2022%20SS/Dynamische%20Speicherverwaltung/sizeof/#sizeoftype","title":"<code>sizeof(&lt;TYPE&gt;)</code>","text":"Type Size int 4 char 1 float 4 double 8 String (= Pointer) 8 void 1"},{"location":"2022%20SS/Graphen/Graph/","title":"Graph","text":"<ul> <li>Graph \\(G = (V, E)\\)<ul> <li>\\(V = \\set{1,2, ..., |V|}\\) - Menge von Knoten</li> <li>\\(E \\subseteq V \\times V\\) - Menge von Pfeilen/Kanten</li> </ul> </li> </ul>"},{"location":"2022%20SS/Graphen/Graph/#gerichtetungerichtet","title":"Gerichtet/Ungerichtet","text":"<ul> <li>Ein gerichteter Graph besteht aus Pfeilen von \\(v\\) nach \\(v'\\).</li> <li>Ein ungerichteter Graph besteht aus Kanten, sodass \\((v,v') \\in E \\implies (v', v) \\in E\\).</li> </ul>"},{"location":"2022%20SS/Graphen/Graph/#darstellung-adjazenzmatrix","title":"Darstellung - Adjazenzmatrix","text":"<ul> <li>Speichert f\u00fcr alle Kanten entweder 0 (<code>false</code>) oder 1 (<code>true</code>) in zweidimensionalem Array</li> <li>Ben\u00f6tigt \\(|V|^2\\) Bits/Booleans</li> <li>Ung\u00fcnstig, wenn die Anzahl an Verbindungen klein ist</li> </ul>"},{"location":"2022%20SS/Graphen/Graph/#darstellung-adjazenzliste","title":"Darstellung - Adjazenzliste","text":"<ul> <li>Gut f\u00fcr das Verfolgen von Pfaden</li> <li>Schlecht f\u00fcr das Hinzuf\u00fcgen oder Entfernen von Knoten</li> <li>Jeder Knoten wird mit einer zus\u00e4tzlichen Liste von Endknoten gespeichert</li> <li>Knoten in Array (statisch) oder in doppelt verketteter Liste (dynamisch)</li> </ul>"},{"location":"2022%20SS/Graphen/Graph/#traversierung","title":"Traversierung","text":"<ul> <li>Algorithmus mittels Stack und Markierung<ul> <li>wei\u00df - neu</li> <li>grau - eingereiht</li> <li>schwarz - besucht</li> </ul> </li> <li>Startknoten \\(v_0\\) auf Stack/Queue</li> <li> <p>Solange Stack/Queue nicht leer:</p> <ul> <li>Einen Knoten entnehmen und schwarz markieren</li> <li>Alle wei\u00dfen Nachbarknoten grau markieren und in Stack/Queue einreihen</li> </ul> </li> <li> <p>Breitensuche - Queue</p> </li> <li>Tiefensuche - Stack</li> </ul>"},{"location":"2022%20SS/Hash%20Tables/Hash%20Table/","title":"Hash Table","text":"<ul> <li>Kombination aus Array und Liste</li> <li>Elemente werden in Array nicht von links nach rechts, sondern durch Hashfunktion zugewiesen</li> </ul>"},{"location":"2022%20SS/Hash%20Tables/Hash%20Table/#einfugen","title":"Einf\u00fcgen","text":"<ul> <li>Hash des Element-Schl\u00fcssels (z.B. Student-Matrikelnummer)</li> </ul>"},{"location":"2022%20SS/Hash%20Tables/Hash%20Table/#suchen","title":"Suchen","text":"<ul> <li>Index = Hash des Element-Schl\u00fcssels</li> <li>Solange mit implementierter Strategie Index erh\u00f6hen, bis der Schl\u00fcsselwert \u00fcbereinstimmt</li> <li>Suchen anhand anderer Attribute (au\u00dfer Schl\u00fcssel) nicht optimiert, stattdessen lineare Suche</li> </ul>"},{"location":"2022%20SS/Hash%20Tables/Hash%20Table/#loschen","title":"L\u00f6schen","text":"<ul> <li>Element auf <code>NULL</code> zu setzen nicht m\u00f6glich, weil eventuell Elemente desselben Hashes eingef\u00fcgt wurden</li> <li>M\u00f6gliche Algorithmen<ol> <li>Platzhalter<ul> <li>Einfach zu realisieren</li> <li>Keine \u00c4nderungen an anderen Funktionen notwendig</li> </ul> </li> <li>Neuberechnung nachfolgender Eintr\u00e4ge<ul> <li>Aufwendig bei gro\u00dfem Cluster</li> <li>Beschleunigt die Suche</li> </ul> </li> </ol> </li> </ul>"},{"location":"2022%20SS/Hash%20Tables/Hash%20Table/#strategien","title":"Strategien","text":"<ul> <li>Kollision - Fall, dass zwei unterschiedliche Eintr\u00e4ge auf denselben Hash/Index eines Arrays zeigen</li> <li>Betrachte Array als Ring (modulo)</li> <li>Erzwungener Abbruch, nachdem alle Felder durchsucht wurden</li> </ul>"},{"location":"2022%20SS/Hash%20Tables/Hash%20Table/#linear-probing","title":"Linear Probing","text":"<ul> <li>\\(h(k, i) = (k + i) \\mod m\\)</li> <li>Index um 1 erh\u00f6hen</li> <li>Problem:<ul> <li>Kollisionsballung verschlechtert Laufzeitverhalten</li> </ul> </li> </ul>"},{"location":"2022%20SS/Hash%20Tables/Hash%20Table/#quadratic-probing","title":"Quadratic Probing","text":"<ul> <li>\\(h(k, i) = (k + c_1 * i + c_2 * i^2) \\mod m\\)</li> <li>Lege \\(c_1\\) und \\(c_2\\) f\u00fcr ein Hash Table konstant an</li> <li>Nimmt immer gr\u00f6\u00dfer werdende Spr\u00fcnge</li> </ul>"},{"location":"2022%20SS/Hash%20Tables/Hash%20Table/#double-hashing","title":"Double Hashing","text":"<ul> <li>\\(h(k, i) = (k + i * h_2(k)) \\mod m\\)</li> <li>H\u00e4ngt von einer unterschiedlichen Hashfunktion \\(h_2(k)\\) ab</li> <li>Sprungweite h\u00e4ngt vom Schl\u00fcssel ab</li> </ul>"},{"location":"2022%20SS/Hash%20Tables/Hash%20Table/#chaining","title":"Chaining","text":"<ul> <li>Jeder Hashwert ist im Array eine verkettete Liste von Eintr\u00e4gen</li> <li>Dynamisch</li> </ul>"},{"location":"2022%20SS/Hash%20Tables/Hashfunktion/","title":"Hashfunktion","text":""},{"location":"2022%20SS/Hash%20Tables/Hashfunktion/#kriterien-fur-gute-hashfunktionen","title":"Kriterien f\u00fcr gute Hashfunktionen","text":"<p>Geringe Wahrscheinlichkeit von Kollisionen</p> <ul> <li>M\u00f6glichst gleichm\u00e4\u00dfige Verteilung der Hashwerte auf erwartete Eingabewerte</li> </ul> <p>Chaos</p> <ul> <li>\u00c4hnliche Eingabewerte sollen zu m\u00f6glichst verschiedenen Hashwerten f\u00fchren</li> <li>Idealfall: \u00c4ndern eines Eingabe-Bits = \u00c4ndern der H\u00e4lfte aller Hash-Bits</li> </ul> <p>Surjektivit\u00e4t</p> <ul> <li>Kein Hashwert soll unm\u00f6glich sein</li> </ul> <p>Effizienz</p> <ul> <li>Funktion muss schnell berechenbar sein</li> <li>Funktion muss ohne gro\u00dfen Speicherverbrauch auskommen</li> </ul> <p>L\u00f6sung: Kryptographische Hashfunktionen (md5, sha1)</p>"},{"location":"2022%20SS/Listen/Liste/","title":"Liste","text":"<ul> <li>Lassen sich zur Laufzeit dimensionieren - H\u00f6here Flexibilit\u00e4t bedeutet verringerte Zugriffsgeschwindigkeit</li> <li>Einf\u00fcgen von Elementen</li> <li>Suchen von Elementen</li> <li>L\u00f6schen von Elementen</li> <li>(\u00c4ndern der Reihenfolge)</li> </ul>"},{"location":"2022%20SS/Listen/Liste/#einfach-verkettete-liste","title":"Einfach verkettete Liste","text":"<ul> <li>\"Horizontales Stapeln\" durch Aneinanderh\u00e4ngen</li> <li>Elemente (bis auf das letzte) verweisen auf Nachfolger</li> <li>Erstes Element (Head) muss gespeichert werden</li> <li>Zeiger auf <code>NULL</code> gilt als Ende der Liste</li> </ul>"},{"location":"2022%20SS/Listen/Liste/#mit-zusatzlichem-ende-der-liste","title":"Mit zus\u00e4tzlichem Ende der Liste","text":"<ul> <li>Erleichtert das Einf\u00fcgen neuer Elemente am Ende der Liste (Tail)</li> </ul>"},{"location":"2022%20SS/Listen/Liste/#doppelt-verkettete-liste","title":"Doppelt verkettete Liste","text":"<ul> <li>Erleichtert das L\u00f6schen von Elementen</li> </ul>"},{"location":"2022%20SS/Listen/Liste/#ring","title":"Ring","text":"<ul> <li>Letztes Element zeigt auf Head</li> </ul>"},{"location":"2022%20SS/Listen/Liste/#stapel-kellerspeicher-stack","title":"Stapel / Kellerspeicher (Stack)","text":"<ul> <li>Erlaubt nur zwei Grundoperationen:<ul> <li>Ablegen (push)</li> <li>Entnehmen des obersten Elements (pop)</li> </ul> </li> <li>Last-in-first-out (LIFO)</li> </ul>"},{"location":"2022%20SS/Listen/Liste/#schlange-queue","title":"Schlange (Queue)","text":"<ul> <li>Erlaubt nur zwei Grundoperationen:<ul> <li>Einf\u00fcgen an den Anfang (enqueue)</li> <li>Entnehmen am Ende (dequeue)</li> </ul> </li> <li>First-in-first-out (FIFO)</li> </ul>"},{"location":"2022%20SS/%C3%9Cbersetzung/Assembler/","title":"Assembler","text":""},{"location":"2022%20SS/%C3%9Cbersetzung/Assembler/#aufbau-von-assembler-kommandos","title":"Aufbau von Assembler-Kommandos","text":"<pre><code>Operator Ziel [Quelle]\n\n- Operator = \"add\", \"mov\", \"inc\"...\n\n- Ziel/Quelle = Konstante, Speicherstelle oder Register\n</code></pre>"},{"location":"2022%20SS/%C3%9Cbersetzung/Assembler/#opcodes","title":"OpCodes","text":"<ul> <li>Operatoren haben Nummern (\"OpCodes\"), z.B. \"add\" = 83.</li> <li>x86 CPUs kennen ca. 200 OpCodes.</li> </ul>"},{"location":"2022%20SS/%C3%9Cbersetzung/Buildprozess/","title":"Buildprozess","text":"<ul> <li>Programme sind in Hochsprachen geschrieben und m\u00fcssen in Maschinensprache \u00fcbersetzt werden.</li> <li>In Hochsprachen k\u00f6nnen Funktionen (und andere Teile des Codes) sowie Funktionsbibliotheken (wieder-)verwendet werden.</li> <li>In Hochsprachen kann umfangreicher Code aus Lesbarkeit in viele Dateien unterteilt werden, die bei \u00dcbersetzung zusammengeb\u00fcndelt werden.</li> </ul> <p>&gt; Code <code>quelltext.c</code> enth\u00e4lt Pr\u00e4pozessor-Anweisungen (z.B. <code>#include</code>, <code>#ifdef</code> usw.)</p> <p>&gt; Pr\u00e4prozessor/Compiler Von C zu Assembler-Code zu Objektdateien (<code>quelltext.o</code>)</p> <p>&gt; Linker Ausf\u00fchrbare Anwendung (<code>quelltext.exe</code>)</p>"},{"location":"2022%20SS/%C3%9Cbersetzung/CPU/","title":"CPU","text":""},{"location":"2022%20SS/%C3%9Cbersetzung/CPU/#vorgang","title":"Vorgang","text":"<ul> <li>Kommando wird aus dem Speicher/Heap in Kommandoregister geladen</li> <li>Kommandologik f\u00fchrt aktuelles Kommando aus<ul> <li>Programmz\u00e4hler manipulieren (z.B. jmp-Befehl)</li> <li>Daten lesen/schreiben (zwischen einem Rechenregister AX, BX, CX, DX und dem Speicher/Heap oder Stackpointer SP)</li> <li>Rechne/Vergleiche (arbeitet auf Rechenregistern)</li> </ul> </li> <li>Programmz\u00e4hler wird um 1 erh\u00f6ht (falls nicht manipuliert)</li> </ul>"},{"location":"2022%20SS/%C3%9Cbersetzung/Maschinensprache/","title":"Maschinensprache","text":"<p>Rechner basieren auf Von-Neumann-Architektur, d.h. CPU f\u00fchrt schrittweise Kommandos (in Maschinensprache) aus.</p> <p>Bus-System transportiert Daten zwischen CPU und Ein-/Ausgabewerk oder Speicherwerk.</p> <p>Speicherwerk h\u00e4lt Daten und Befehlsfolgen vor.</p> <p>Ein-/Ausgabewerk bereitet Daten f\u00fcr Ein-/Ausgabe auf.</p> <p>Merkmale - Hochsprache 1. Kontrollstrukturen 2. Prozedurale Abstraktion 3. Formale Paradigmen     1. objektorientiert     2. funktional/logisch</p> <p>Merkmale - Maschinensprache 1. Simple Vergleichsoperationen 2. Sequentielle Ausf\u00fchrung 3. Sprungbasierte Ablaufsteuerung (goto-statements considered harmful) 4. Keine Kapselung von Daten 5. Prinzip der Zustands\u00e4nderung</p> <p>Unterschiede Hoch- und Maschinensprache &lt; | Hochsprache | Maschinensprache -- | -- | -- Lesbarkeit | x | Einfache Fehlersuche | x |  Realisierbarkeit in Hardware | | x</p>"},{"location":"2022%20WS/01%20Einf%C3%BChrung/Datentypen/","title":"Datentypen","text":""},{"location":"2022%20WS/01%20Einf%C3%BChrung/Datentypen/#java","title":"Java","text":""},{"location":"2022%20WS/01%20Einf%C3%BChrung/Datentypen/#primitive-datentypen","title":"Primitive Datentypen","text":"<ul> <li>Numerisch<ul> <li>Ganzzahlen: <code>byte, short, int, long, char</code></li> <li>Gleitkomma: <code>float, double</code></li> </ul> </li> <li>Andere<ul> <li><code>boolean</code></li> </ul> </li> </ul>"},{"location":"2022%20WS/01%20Einf%C3%BChrung/Datentypen/#referenz-datentypen","title":"Referenz-Datentypen","text":"<ul> <li>Arrays</li> <li>Klassen/Objekte</li> <li>Interfaces</li> <li><code>null</code>-Datentyp</li> </ul>"},{"location":"2022%20WS/01%20Einf%C3%BChrung/Datentypen/#python","title":"Python","text":"<p>Primitive Typen entsprechen immutable types.</p> Typ Immutable bool x int x float x list tuple x str x set frozenset x dict Klassen/Objekte"},{"location":"2022%20WS/02%20Klassen/Abstrakte%20Datentypen%20%28ADT%29/","title":"Abstrakte Datentypen (ADT)","text":"<p>Wenn Attribute nur \u00fcber Methoden ver\u00e4ndert werden k\u00f6nnen, spricht man von \"Abstrakten Datentypen\".</p> <ul> <li>ADT sollten bei objektorientierter Programmierung immer genutzt werden<ul> <li>Aktionen (<code>SETTER</code>) ver\u00e4ndern Objekt-Attribute ohne R\u00fcckgabe</li> <li>Abfragen (<code>GETTER</code>) liefern Aussagen \u00fcber aktuelle Attributwerte</li> </ul> </li> <li>Abstrakte Datentypen kapseln die Attribute nach au\u00dfen hin</li> </ul>"},{"location":"2022%20WS/02%20Klassen/Abstrakte%20Datentypen%20%28ADT%29/#java","title":"Java","text":"<p>In Java realisierbar durch <code>private</code> und <code>protected</code>.</p>"},{"location":"2022%20WS/02%20Klassen/Abstrakte%20Datentypen%20%28ADT%29/#python","title":"Python","text":"<p>Python erlaubt immer direkten Zugriff auf Attribute</p> <ul> <li>strukturell lassen sich ADT nicht erzwingen</li> <li>private Attribute normalerweise mit Unterstrich kennzeichnen (<code>_attribut</code>)</li> <li>siehe Getter und Setter</li> </ul>"},{"location":"2022%20WS/02%20Klassen/Attribute/","title":"Attribute","text":""},{"location":"2022%20WS/02%20Klassen/Attribute/#klassen-attribute","title":"Klassen-Attribute","text":"<ul> <li>auch statische Attribute genannt</li> <li>Java<ul> <li>durch <code>static</code> ver\u00e4nderbar von \u00fcberall, abh\u00e4ngig von der Sichtbarkeit<ul> <li>deshalb popul\u00e4re Fehlerquelle</li> </ul> </li> <li>durch <code>static final</code> wird das Attribut zu einer Konstante.</li> </ul> </li> <li>Python<ul> <li>direkt in Klasse deklariert</li> <li>wird in Instanzen als Objekt-Attributen kopiert</li> </ul> </li> </ul>"},{"location":"2022%20WS/02%20Klassen/Attribute/#objekt-attribute","title":"Objekt-Attribute","text":"<ul> <li>auch Instanz-Attribute genannt</li> </ul> <pre><code>class Dog:\n    kind = \"canine\" # KLASSEN-ATTRIBUT\n\n    def __init__(self, name):\n        self.name = name # OBJEKT-ATTRIBUT\n\nd = Dog(\"Rookie\")\nd.kind # \"canine\" (KOPIERTER Wert)\nd.name # \"Rookie\"\n\nDog.kind # \"canine\" (statisch)\n</code></pre>"},{"location":"2022%20WS/02%20Klassen/Call%20By/","title":"Call By","text":"<p>Argumente eines Methoden-Aufrufs haben verschiedenes Verhalten, abh\u00e4ngig davon, ob es sich um einen primitiven Datentyp oder um eine Referenz handelt. (Datentypen)</p> <p>call by value (primitiver Datentyp / immutable)</p> <ul> <li>Argument wird f\u00fcr die Methode \"kopiert\"</li> <li>ver\u00e4ndert sich deshalb nicht au\u00dferhalb der Methode</li> </ul> <p>call by reference (Referenz / mutable)</p> <ul> <li>Argument wird nicht kopiert</li> <li>Intern wird also die Speicheradresse \u00fcbergeben</li> </ul>"},{"location":"2022%20WS/02%20Klassen/Datenkapselung/","title":"Datenkapselung","text":""},{"location":"2022%20WS/02%20Klassen/Datenkapselung/#implementierungssicht","title":"Implementierungssicht","text":"<ul> <li>Interna des Objekts werden verborgen</li> <li>Konsistenz des Objekts kann garantiert werden</li> </ul>"},{"location":"2022%20WS/02%20Klassen/Datenkapselung/#nutzungssicht","title":"Nutzungssicht","text":"<ul> <li>Nutzer kann nur mit sichtbar gemachte Methoden interagieren</li> <li>Sichtbar gemachte Methoden definieren die Schnittstelle des Objekts</li> </ul>"},{"location":"2022%20WS/02%20Klassen/Datenkapselung/#geheimnisprinzip-der-oop","title":"Geheimnisprinzip der OOP","text":"<ul> <li>\"mache nur sichtbar, was der Nutzer wirklich braucht\"</li> <li>erlaubt ein f\u00fcr den Nutzer transparentes \u00c4ndern der Implementierung</li> </ul> <p>Siehe Sichtbarkeit.</p>"},{"location":"2022%20WS/02%20Klassen/Getter%20und%20Setter/","title":"Getter und Setter","text":""},{"location":"2022%20WS/02%20Klassen/Getter%20und%20Setter/#java","title":"Java","text":"<p>Durch simple Methoden <code>getID()</code>, <code>setID()</code> ohne Besonderheit umgesetzt.</p>"},{"location":"2022%20WS/02%20Klassen/Getter%20und%20Setter/#python","title":"Python","text":"<p>Auf zwei m\u00f6gliche Weisen implementierbar. <pre><code>class MyObject:\n    def __init__(self, id):\n        self._id = id\n\n    def getid(self):\n        return self._id\n\n    def setid(self, value):\n        self._id = value\n\n    def delid(self):\n        del self._id\n\n    id = property(getid, setid, delid, \"Property description.\")\n</code></pre></p> <pre><code>class MyObject:\n    def __init__(self, id):\n        self._id = id\n\n    @property\n    def id(self):\n\"\"\"Property description.\"\"\"\n        return self._id\n\n    @id.setter\n    def id(self, value):\n        self._id = value\n\n    @id.deleter\n    def id(self):\n        del self._id\n</code></pre>"},{"location":"2022%20WS/02%20Klassen/Methodentypen/","title":"Methodentypen","text":""},{"location":"2022%20WS/02%20Klassen/Methodentypen/#java","title":"Java","text":"<p>In Java unterscheidet man zwischen Klassen-Methoden (<code>static</code>) und Objekt/Instanz-Methoden.</p>"},{"location":"2022%20WS/02%20Klassen/Methodentypen/#python","title":"Python","text":"<p>3 Kategorien von Methoden.</p>"},{"location":"2022%20WS/02%20Klassen/Methodentypen/#instanz-methoden","title":"Instanz-Methoden","text":"<ul> <li>erstes Argument: <code>self</code></li> <li>geh\u00f6ren zur konkreten Instanz</li> </ul>"},{"location":"2022%20WS/02%20Klassen/Methodentypen/#klassen-methoden","title":"Klassen-Methoden","text":"<ul> <li>erstes Argument: <code>cls</code></li> <li>Aufruf durch <code>Klasse.methode()</code> oder <code>instanz.methode()</code></li> </ul>"},{"location":"2022%20WS/02%20Klassen/Methodentypen/#statische-methoden","title":"Statische Methoden","text":"<ul> <li>kein implizites Argument</li> <li>direkt in der Klasse definiert</li> <li>Aufruf durch <code>Klasse.methode()</code> oder <code>cls.methode()</code></li> </ul> <pre><code>class Math:\n    @classmethod\n    def version(cls):\n        return \"1.0\"\n\n    @staticmethod\n    def add(a, b):\n        return a + b\n\n    @classmethod\n    def rechne(cls):\n        return cls.add(22, 20)\n</code></pre>"},{"location":"2022%20WS/02%20Klassen/Objekterzeugung%20und%20-L%C3%B6schung/","title":"Objekterzeugung und -L\u00f6schung","text":"<p>Objekte werden aus Klassen (Objekt-Vorlagen) mit dem Aufrufen eines Konstruktors erzeugt. Wenn das Objekt nicht mehr gebraucht wird, muss der belegte Speicher freigegeben werden.</p>"},{"location":"2022%20WS/02%20Klassen/Objekterzeugung%20und%20-L%C3%B6schung/#java","title":"Java","text":"<p>Erzeugen <pre><code>public class MyObject {\nprivate int id;\n\npublic MyObject(int id) {\nthis.id = id;\n}\n}\n\nMyObject mo = new MyObject(123);\n</code></pre></p> <p>L\u00f6schen Automatisch durch Garbage Collector.</p>"},{"location":"2022%20WS/02%20Klassen/Objekterzeugung%20und%20-L%C3%B6schung/#python","title":"Python","text":"<p>Erzeugen <pre><code>class MyObject():\n    def __init__(self, id):\n        self.id = id\n\nmo = MyObject(123)\n</code></pre></p> <p>L\u00f6schen <pre><code>del mo\n</code></pre></p>"},{"location":"2022%20WS/02%20Klassen/Pakete/","title":"Pakete","text":"<p>Pakete erlauben die hierarchische Strukturierung von Code.</p>"},{"location":"2022%20WS/02%20Klassen/Pakete/#java","title":"Java","text":"<ul> <li>Klassen mit demselben Namen k\u00f6nnen in mehreren Packages definiert sein.</li> <li>Pakete entsprechen normalerweise auch individuellen Ordnern im Projektverzeichnis.</li> <li><code>java.lang</code> ist das \"Default-Paket\" und muss nicht extra importiert werden.</li> </ul> <pre><code>// Package aller Klassen, die in dieser Datei definiert werden\npackage mypackage;\n\n// Erm\u00f6glicht das Nutzen aller Klassen aus dem java.util Package\nimport java.util.*;\n\n// Erm\u00f6glicht das Nutzen der Klasse OtherClass aus dem Package otherpackage\nimport otherpackage.OtherClass;\n</code></pre> <pre><code>// Nutzt die Klasse OtherClass ohne Import\notherpackage.OtherClass instanz = new otherPackage.OtherClass();\n</code></pre>"},{"location":"2022%20WS/02%20Klassen/Pakete/#python","title":"Python","text":"<p>Python unterscheidet zwischen Modulen und Paketen.</p>"},{"location":"2022%20WS/02%20Klassen/Pakete/#modul","title":"Modul","text":"<ul> <li>entspricht einer einzelnen Python-Datei (<code>my_module.py</code>)</li> <li>importieren mit <code>import my_module</code></li> </ul>"},{"location":"2022%20WS/02%20Klassen/Pakete/#paket","title":"Paket","text":"<ul> <li>entspricht einem Ordner</li> <li>Ordner muss eine Datei namens <code>__init__.py</code> beinhalten</li> </ul>"},{"location":"2022%20WS/02%20Klassen/Sichtbarkeit/","title":"Sichtbarkeit","text":"<p>Alle Klassen, Methoden und Variablen in Java haben eine \"Sichtbarkeit\".</p> UML-Symbol Sichtbarkeit Selbes Package Unterklassen Au\u00dferhalb des Package <code>-</code> <code>private</code> <code>~</code> <code>default (\"package-private\")</code> x <code>#</code> <code>protected</code> x x <code>+</code> <code>public</code> x x x"},{"location":"2022%20WS/02%20Klassen/Sichtbarkeit/#sichtbarkeit-von-klassen","title":"Sichtbarkeit von Klassen","text":"<ul> <li>mehrere Klassendefinitionen pro Datei m\u00f6glich</li> <li>genau eine Klasse muss <code>public</code> sein und dem Dateinamen gleichen</li> <li>Klassen ohne <code>public</code> sind nur innerhalb des Datei-Packages nutzbar</li> </ul> <pre><code>package mypackage;\n\npublic class Klasse1 { // public\n...\n}\n\nclass Klasse2 { // package-private\n...\n}\n</code></pre>"},{"location":"2022%20WS/02%20Klassen/%C3%9Cberladen/","title":"\u00dcberladen","text":""},{"location":"2022%20WS/02%20Klassen/%C3%9Cberladen/#java","title":"Java","text":"<p>Es k\u00f6nnen mehrere Methoden mit dem gleichen Namen aber unterschiedlicher Signatur deklariert werden. <pre><code>public int max(int a, int b) {\nreturn a &lt; b ? b : a;\n}\n\npublic double max(double a, double b) {\nreturn a &lt; b ? b : a;\n}\n</code></pre></p> <p>(auch mit Konstruktoren m\u00f6glich)</p>"},{"location":"2022%20WS/02%20Klassen/%C3%9Cberladen/#python","title":"Python","text":"<p>Nicht m\u00f6glich, weil Methoden wie Attribute behandelt werden. Weitere Deklarationen desselben Namens \u00fcberschreiben die vorherige Definition.</p> <p>Stattdessen k\u00f6nnen Default-Werte f\u00fcr Argumente definiert werden.</p> <pre><code>def refresh_page(delete_cache = False):\n    # Implementierung...\n\nrefresh_page() # delete_cache = False\n\nrefresh_page(True) # delete_cache = True\n\nrefresh_page(delete_cache=True) # expliziter Parameter\n</code></pre>"},{"location":"2022%20WS/03%20Vererbung%20und%20Polymorphie/Abstrakte%20Klassen/","title":"Abstrakte Klassen","text":"<ul> <li>Klassen, von denen keine konkreten Objekte/Instanzen erzeugt werden k\u00f6nnen</li> <li>werden als Schnittstellen verwendet (mit teilweiser Standardimplementierungen)</li> <li>k\u00f6nnen abstrakte Methoden(-Signaturen) beinhalten, welche erst in Unterklassen einen K\u00f6rper bekommen</li> <li>falls die Unterklasse einer abstrakten Oberklasse auch als <code>abstract</code> markiert ist, m\u00fcssen die abstrakten Methoden der Oberklasse nicht implementiert werden</li> </ul> <pre><code>abstract class Shape {\nprivate int color;\n\npublic Shape(int color) {\nthis.color = color;\n}\n\npublic abstract double getArea();\n}\n\nclass Circle extends Shape {\nprivate double radius;\n\npublic Circle(int color, double radius) {\nsuper(color);\nthis.radius = radius;\n}\n\n@Override\npublic double getArea() { // MUSS \u00fcberschrieben werden, weil zuvor abstract\n// area = \u03c0r\u00b2\nreturn Math.PI * radius * radius;\n}\n}\n</code></pre>"},{"location":"2022%20WS/03%20Vererbung%20und%20Polymorphie/Interfaces/","title":"Interfaces","text":"<p>Interfaces = Schnittstellen</p> <p>Interfaces k\u00f6nnen von anderen Interfaces erben (<code>extends</code>).</p>"},{"location":"2022%20WS/03%20Vererbung%20und%20Polymorphie/Interfaces/#implementierungs-beziehung","title":"Implementierungs-Beziehung","text":"<ul> <li>Attribute innerhalb eines <code>interface</code> sind implizit <code>static final</code> (also konstant)</li> <li>leere Interfaces hei\u00dfen \"Marker\"-Schnittstellen</li> </ul>"},{"location":"2022%20WS/03%20Vererbung%20und%20Polymorphie/Interfaces/#java-8","title":"Java 8+","text":"<ul> <li>m\u00f6gliche Mehrfachvererbung durch <code>default</code> Methoden</li> <li>Definition von \"Utilities\" durch <code>static</code> Methoden</li> </ul>"},{"location":"2022%20WS/03%20Vererbung%20und%20Polymorphie/Interfaces/#vergleich-zu-abstrakten-klassen","title":"Vergleich zu abstrakten Klassen","text":"Interface Abstrakte Klasse instanziierbar Erb-Notation <code>class Klasse implements Interface1, Interface2 {}</code> <code>class Klasse extends OberKlasse {}</code> mehrfach verwendbar x"},{"location":"2022%20WS/03%20Vererbung%20und%20Polymorphie/Mehrfachvererbung/","title":"Mehrfachvererbung","text":"<p>Eine Klasse kann (prinzipiell) von mehreren Basisklassen erben (\"Mehrfachvererbung\"). In Java ist der \u00dcbersicht halber nur Einfachvererbung m\u00f6glich.</p>"},{"location":"2022%20WS/03%20Vererbung%20und%20Polymorphie/Mehrfachvererbung/#interfaces-mit-default-methoden","title":"Interfaces mit Default-Methoden","text":"<p>Java 8+ erlaubt default-Methoden innerhalb von Interfaces, welche eine Standard-Implementierung vorgeben.</p> <pre><code>interface MyInterface {\nvoid firstMethod();\nvoid secondMethod();\n\ndefault void callAllMethods() {\nfirstMethod();\nsecondMethod();\n}\n}\n</code></pre> <p>Damit ist Mehrfachvererbung auch in Java m\u00f6glich.</p> <pre><code>interface Printer {\ndefault void printName() {\nSystem.out.println(\"Unknown\");\n}\n}\n\ninterface InputReceiver {\ndefault void handleInput(char keyPressed) {\nSystem.out.println(\"Pressed key \" + keyPressed);\n}\n}\n\nclass Game implements Printer, InputReceiver {}\n\nGame game = new Game();\ngame.printName(); // \"Unknown\"\ngame.handleInput('a'); // \"Pressed key a\"\n</code></pre>"},{"location":"2022%20WS/03%20Vererbung%20und%20Polymorphie/Mehrfachvererbung/#doppelte-methoden","title":"Doppelte Methoden","text":"<p>Fehler, falls zwei implementierte Interfaces eine Methode mit gleichem Namen und gleichen Argumenten definieren.</p> <pre><code>interface Bob1 {\ndefault void bob() {\nSystem.out.println(\"Bob1::bob\");\n}\n}\n\ninterface Bob2 {\ndefault void bob() {\nSystem.out.println(\"Bob2::bob\");\n}\n}\n\nclass Bob implements Bob1, Bob2 {}\n</code></pre> <p>Kann behoben werden durch Disambiguation.</p> <pre><code>class Bob implements Bob1, Bob2 {\n@Override\npublic void bob() {\nBob2.super.bob();\n}\n}\n</code></pre>"},{"location":"2022%20WS/03%20Vererbung%20und%20Polymorphie/Polymorphie/","title":"Polymorphie","text":"<p>Polymorphie = Vielgestaltigkeit</p>"},{"location":"2022%20WS/03%20Vererbung%20und%20Polymorphie/Polymorphie/#statische-bindung","title":"Statische Bindung","text":"<ul> <li>Attribute werden nicht \u00fcberschrieben (es kann mehrere Attribute mit demselben Namen geben)</li> <li>private Methoden k\u00f6nnen nicht \u00fcberschrieben werden (sind automatisch <code>final</code>)</li> <li>statische Methoden \u00fcberschreiben sich nicht (Teil der Klasse statt der instanziierten Objekte)</li> </ul>"},{"location":"2022%20WS/03%20Vererbung%20und%20Polymorphie/UML/","title":"UML","text":"<p>UML-Diagramme sind Projektentw\u00fcrfe. - Klassen     - Attribute     - Methoden - Klassenbeziehungen     - Datentypen der Attribute     - Signaturen der Methoden</p> Duck <code>- name : string</code> <code>- color : int</code> <code>+ Duck(string, int)</code> <code>+ getName() : string</code> <code>~ getColor() : int</code>"},{"location":"2022%20WS/03%20Vererbung%20und%20Polymorphie/UML/#klassendiagramm","title":"Klassendiagramm","text":"<ul> <li>Klassenname: zentriert und in Fettschrift<ul> <li>\u00dcberschrift ggf. <code>&lt;&lt;interface&gt;&gt;</code>, <code>&lt;&lt;abstract&gt;&gt;</code> oder <code>&lt;&lt;enumeration&gt;&gt;</code></li> </ul> </li> <li>Liste von Attributen <code>&lt;-|~|#|+&gt; &lt;name&gt;: &lt;type&gt;</code><ul> <li>Sichtbarkeit</li> <li>Name</li> <li>Typ</li> </ul> </li> <li>Liste von Methoden/Operationen <code>&lt;-|~|#|+&gt; &lt;name&gt;(&lt;param-type ...&gt;): &lt;return-type&gt;</code><ul> <li>Sichtbarkeit</li> <li>Name</li> <li>Argumententypen</li> <li>R\u00fcckgabetyp</li> </ul> </li> </ul>"},{"location":"2022%20WS/03%20Vererbung%20und%20Polymorphie/UML/#besonderheiten","title":"Besonderheiten","text":"<ul> <li>abstrakte Klassen und Methoden kursiv oder \\ <li>statische Attribute und Methoden unterstrichen oder \\"},{"location":"2022%20WS/03%20Vererbung%20und%20Polymorphie/UML/#generalisierung","title":"Generalisierung","text":"<ul> <li>Pfeil von Unterklasse auf Oberklasse</li> <li><code>extends</code> = durchgezogen</li> <li><code>implements</code> = gestrichelt</li> </ul>"},{"location":"2022%20WS/03%20Vererbung%20und%20Polymorphie/Upcast%20und%20Downcast/","title":"Upcast und Downcast","text":"<p>Nur in Java relevant, weil es eine streng typisierte Sprache ist.</p>"},{"location":"2022%20WS/03%20Vererbung%20und%20Polymorphie/Upcast%20und%20Downcast/#upcast-verallgemeinern","title":"Upcast (Verallgemeinern)","text":"<p>Instanz einer Unterklasse wird als eine ihrer Oberklassen behandelt.</p> <ul> <li>immer erlaubt</li> <li>nur Methoden und Attribute der Superklasse verwendbar</li> <li>beim Aufrufen einer Methode wird dennoch die \"unterste\" \u00fcberschriebene Variante aufgerufen (dynamisches Binding / late binding)</li> </ul>"},{"location":"2022%20WS/03%20Vererbung%20und%20Polymorphie/Upcast%20und%20Downcast/#downcast-spezifizieren","title":"Downcast (Spezifizieren)","text":"<p>Instanz einer Oberklasse wird als eine ihrer Unterklassen behandelt.</p> <ul> <li>Casting Exception, falls die Instanz nicht der gecasteten Unterklasse entspricht</li> <li>erlaubt das Nutzen von erg\u00e4nzten Methoden und Attributen</li> </ul> <pre><code>// Upcast\nShape shape = new Circle(...);\n\n// Downcast\nCircle circle = (Circle) shape;\n</code></pre>"},{"location":"2022%20WS/03%20Vererbung%20und%20Polymorphie/Vererbung/","title":"Vererbung","text":"<p>Klassen k\u00f6nnen von anderen Klassen \"abgeleitet\" werden.</p> <p>Abgeleitete Klassen</p> <ul> <li>erben alle Attribute und Methoden der Basisklasse</li> <li>k\u00f6nnen Attribute und Methoden erg\u00e4nzen</li> <li>k\u00f6nnen Methoden modifizieren/\u00fcberschreiben</li> </ul> <p>Prinzipiell erlauben Programmiersprachen Mehrfachvererbung.</p>"},{"location":"2022%20WS/03%20Vererbung%20und%20Polymorphie/Vererbung/#nomenklatur","title":"Nomenklatur","text":"<ul> <li>Vererbung = Erweiterung = Ableitung</li> <li>Basisklasse = Oberklasse = Elternklasse = Superklasse \\(\\Rightarrow\\) Verallgemeinerung</li> <li>abgeleitete Klasse = Unterklasse = Kindklasse = Subklasse \\(\\Rightarrow\\) Spezialisierung</li> </ul> <pre><code>class Shape {\nprivate int color;\n\npublic Shape(int color) {\nthis.color = color;\n}\n}\n\nclass Circle extends Shape {\nprivate double radius;\n\npublic Circle(int color, double radius) {\nsuper(color);\nthis.radius = radius;\n}\n}\n</code></pre> <pre><code>class Shape:\n    def __init__(self, color):\n        self.color = color\n\nclass Circle(Shape):\n    def __init__(self, color, radius):\n        super(Circle, self).__init__(color)\n        self.radius = radius\n</code></pre>"},{"location":"2022%20WS/03%20Vererbung%20und%20Polymorphie/%C3%9Cberschreiben/","title":"\u00dcberschreiben","text":"<p>Eine Subklasse kann geerbte Methoden der Superklasse \u00fcberschreiben (override), d.h. neu implementieren.</p>"},{"location":"2022%20WS/03%20Vererbung%20und%20Polymorphie/%C3%9Cberschreiben/#java","title":"Java","text":"<p>Methode muss die gleiche Signatur wie in der Superklasse haben und mit <code>@Override</code> gekennzeichnet werden.</p> <p>Konstruktoren</p> <ul> <li>Der Konstruktor einer Unterklasse f\u00fchrt immer zuerst einen Konstruktor der Oberklasse aus.</li> <li>Erste Zeile des Sub-Konstruktors: <code>super( Argumente... )</code></li> </ul> <pre><code>class SuperClass {\nprivate int id;\n\npublic SuperClass(int id) {\nthis.id = id;\n}\n\npublic void print(String msg) {\nSystem.out.println(msg);\n}\n}\n\nclass SubClass extends SuperClass {\nprivate String prefix;\n\npublic SubClass(String prefix, int id) {\nsuper(id);\nthis.prefix = prefix;\n}\n\n@Override\npublic void print(String msg) {\nsuper.print(prefix + msg);\n}\n}\n\n// darf vom Typ SuperClass oder SubClass sein\nSuperClass instanz = new SubClass(\"Printing: \", 0);\ninstanz.id; // 0\ninstanz.print(\"Hallo\"); // \"Printing: Hallo\"\n</code></pre>"},{"location":"2022%20WS/04%20Collections/Collection/","title":"Collection","text":"<p>Collection Interface besitzt Funktionen:</p> <ul> <li>einf\u00fcgen eines Elements</li> <li>l\u00f6schen eines Elements</li> <li>l\u00f6schen aller Elemente</li> <li>abfragen, ob <code>x</code> Teil der Collection ist</li> <li>abfragen, ob leer</li> <li>durchlaufen aller Elemente</li> </ul> <pre><code>interface Collection&lt;E&gt; {\nboolean add(E o);\nboolean remove(Object o);\nvoid clear();\nint size();\nboolean isEmpty();\nObject[] toArray();\nIterator&lt;E&gt; iterator();\n}\n</code></pre> <p>Siehe Iterator. Implementiert durch List und Set.</p>"},{"location":"2022%20WS/04%20Collections/Collection/#vergleich-von-listen-und-mengen-laufzeitkomplexitat","title":"Vergleich von Listen und Mengen (Laufzeitkomplexit\u00e4t)","text":"Klasse add() remove() get() contains() Durchlauf-Reihenfolge <code>ArrayList</code> O(1) O(n) O(1) O(n) Einf\u00fcgung <code>LinkedList</code> ^ (schnell) ^ O(n) ^ Einf\u00fcgung <code>TreeSet</code> O(log n) O(log n) O(log n) Ordnung <code>HashSet</code> O(1) O(1) O(1) unspezifisch"},{"location":"2022%20WS/04%20Collections/Comparable/","title":"Comparable","text":"<p>Schnittstelle, um Objekte vergleichbar zu machen.</p> <ul> <li><code>&lt; 0</code>, falls <code>a &lt; b</code></li> <li><code>== 0</code>, falls <code>a == b</code></li> <li><code>&gt; 0</code>, falls <code>a &gt; b</code></li> </ul> <pre><code>interface Comparable&lt;T&gt; {\nint compareTo(T other);\n}\n\nclass Integer implements Comparable&lt;Integer&gt; {\npublic int compareTo(Integer other) {\nreturn 3 - 7; &lt; 0\n}\n}\n</code></pre>"},{"location":"2022%20WS/04%20Collections/Comparable/#comparator","title":"Comparator","text":"<p>Typ-Generische Schnittstelle, die zwei Objekte desselben Typs</p> <pre><code>interface Comparator&lt;T&gt; {\nint compare(T a, T b);\n}\n</code></pre>"},{"location":"2022%20WS/04%20Collections/Container/","title":"Container","text":"<p>Container definieren eine Speicherung und Verwaltung von Objekten.</p> <ul> <li>Array: einfachste Container-Datenstruktur</li> <li>Java enth\u00e4lt vordefinierte Container-Klassen und -Schnittstellen</li> </ul> <p>Es gibt 2 Arten von Containern:</p> <ul> <li>Collection: reine Sammlung von Objekten</li> <li>Map: Abbildung zwishcen Objekten (z.B. Telefonverzeichnis)</li> </ul>"},{"location":"2022%20WS/04%20Collections/Container/#container-schnittstellen","title":"Container-Schnittstellen","text":"<ul> <li>Collection<ul> <li>Set<ul> <li>SortedSet</li> </ul> </li> <li>List</li> </ul> </li> <li>Map<ul> <li>SortedMap</li> </ul> </li> </ul>"},{"location":"2022%20WS/04%20Collections/Enum/","title":"Enum","text":"<ul> <li>Alternative zu <code>class</code></li> <li>ohne Vererbung</li> <li>f\u00fcr wenige konstante Instanzen</li> </ul> <p>Instanzmethoden:</p> <ul> <li><code>ordinal()</code>: Index der Definition</li> <li><code>compareTo()</code>: Index vergleichen</li> </ul> <p>Klassenmethoden:</p> <ul> <li><code>values()</code>: Iterable aller definierter Konstanten im Enum</li> </ul>"},{"location":"2022%20WS/04%20Collections/Enum/#uml-notation","title":"UML-Notation","text":"<code>&lt;&lt;enumeration&gt;&gt;</code> Weekday <code>+ MONDAY</code> <code>+ TUESDAY</code> <code>+ WEDNESDAY</code> <code>+ THURSDAY</code> <code>+ FRIDAY</code> <code>+ SATURDAY</code> <code>+ SUNDAY</code>"},{"location":"2022%20WS/04%20Collections/Enum/#switch-vergleich","title":"<code>switch</code>-Vergleich","text":"<pre><code>Weekday day = Weekday.SATURDAY;\nswitch (day) {\ncase MONDAY:\ncase TUESDAY:\ncase WEDNESDAY:\ncase THURSDAY:\ncase FRIDAY:\nSystem.out.println(\"Wochentag\");\nbreak;\ncase SATURDAY:\ncase SUNDAY:\nSystem.out.println(\"Wochenende\");\nbreak;\n}\n</code></pre>"},{"location":"2022%20WS/04%20Collections/Generics/","title":"Generics","text":"<p>Siehe Typisierung.</p>"},{"location":"2022%20WS/04%20Collections/Generics/#generische-datentypen","title":"Generische Datentypen","text":"<p>Man will</p> <ul> <li>beliebige Elementtypen zulassen</li> <li>beim Aufrufen von Container-Operationen einen konkreten Typ nutzen</li> </ul>"},{"location":"2022%20WS/04%20Collections/Generics/#losung-1-polymorphe-behalter","title":"L\u00f6sung 1 - Polymorphe Beh\u00e4lter","text":"<ul> <li>alle Elemente als <code>Object</code> behandelt</li> <li>manuelles Downcasting</li> <li>keine Typsicherheit</li> </ul>"},{"location":"2022%20WS/04%20Collections/Generics/#losung-2-generische-datentypen","title":"L\u00f6sung 2 - Generische Datentypen","text":"<ul> <li>Deklaration einer Collection erh\u00e4lt Elementtyp als generischen Typ-Parameter</li> <li>seit Java 5</li> <li><code>List&lt;E&gt;</code> = generischer Typ, <code>E</code> = Typ-Parameter <pre><code>interface List&lt;E&gt; {\nvoid add(int index, E element);\n}\n\nclass ArrayList&lt;E&gt; extends List&lt;E&gt; {\npublic void add(int index, E element) { ... }\n}\n\n// Liste von Strings erzeugen\nArrayList&lt;String&gt; myList = new ArrayList&lt;String&gt;();\n\n// seit Java 7 k\u00fcrzer durch Typ-Inferenz\nArrayList&lt;String&gt; myList = new ArrayList&lt;&gt;();\n</code></pre></li> </ul>"},{"location":"2022%20WS/04%20Collections/Iterator/","title":"Iterator","text":"<p>Ein Iterator bewegt sich \u00fcber eine Sequenz, ohne die unterliegende Datenstruktur zu kennen.</p> <ul> <li>leicht herzustellen</li> <li>bewegen sich in nur eine Richtung</li> </ul> <pre><code>interface Iterator&lt;E&gt; {\nboolean hasNext();\nE next();\nvoid remove();\n}\n</code></pre>"},{"location":"2022%20WS/04%20Collections/Iterator/#iterable","title":"Iterable","text":"<p><code>for-each</code>-Schleifen sind eine einfachere Schreibweise, die <code>iterator()</code>-Methode von <code>Iterable</code>-Objekten (alle Collections sind <code>Iterable</code>) zu nutzen.</p> <pre><code>void cancelAll(Collection&lt;TimerTask&gt; c) {\nfor (TimerTask t : c) {\nt.cancel(); // Aktion auf einzelnem Element\n}\n}\n</code></pre> <pre><code>void cancelAll(Collection&lt;TimerTask&gt; c) {\nfor (Iterator&lt;TimerTask&gt; i = c.iterator(); i.hasNext();) {\nTimerTask t = i.next();\nt.cancel(); // Aktion auf einzelnem Element\n}\n}\n</code></pre>"},{"location":"2022%20WS/04%20Collections/List/","title":"List","text":"<pre><code>interface List&lt;E&gt; extends Collection&lt;E&gt; {\nvoid add(int index, E o);\nboolean addAll(int index, Collection&lt;E&gt; c);\nE get(int index);\nint indexOf(Object o);\nint lastIndexOf(Object o);\nE remove(int index);\nE set(int index, E o);\n}\n</code></pre>"},{"location":"2022%20WS/04%20Collections/List/#arraylist","title":"ArrayList","text":"<ul> <li>realisiert durch internen Array, wessen Gr\u00f6\u00dfe bei <code>add()</code> und <code>remove()</code> automatisch angepasst wird</li> <li>falls Platz f\u00fcr neue Elemente ben\u00f6tigt ist, Array um ca. 50% vergr\u00f6\u00dfern</li> <li>Initiale Gr\u00f6\u00dfe <code>10</code> Elemente (falls nicht im Konstruktor anders angegeben)</li> </ul>"},{"location":"2022%20WS/04%20Collections/List/#linkedlist","title":"LinkedList","text":"<ul> <li>realisiert durch (doppelt) verkettete Liste</li> <li>kann als Stack und als Queue gleichzeitig verwendet werden</li> <li>zus\u00e4tzliche Operationen <code>addFirst(), getFirst(), removeFirst()</code> und <code>addLast(), getLast(), removeLast()</code></li> </ul>"},{"location":"2022%20WS/04%20Collections/Map/","title":"Map","text":"<p>Map = Dictionary = Abbildung</p> <ul> <li>Gruppe von Schl\u00fcssel-Werte-Objektpaaren</li> <li>realisiert assoziativen Speicher (Zugriff \u00fcber individuelle Schl\u00fcssel statt Index)</li> </ul>"},{"location":"2022%20WS/04%20Collections/Map/#eigenschaften","title":"Eigenschaften","text":"<ul> <li>jeder Schl\u00fcssel hat entweder gar keinen oder genau einen Wert</li> <li>falls der Schl\u00fcssel beim Einf\u00fcgen schon vorhanden ist, wird der Wert \u00fcberschrieben</li> <li>l\u00f6schen eines Schl\u00fcssels l\u00f6scht das ganze Paar</li> <li>Sortierung beliebig</li> </ul> <pre><code>interface Map&lt;K, V&gt; {\nvoid clear();\nint size();\nboolean isEmpty();\nV put(K key, V value);\nV get(Object key);\nV remove(Object key);\nboolean containsKey(Object key);\nboolean containsValue(Object value);\n}\n</code></pre>"},{"location":"2022%20WS/04%20Collections/Map/#treemap","title":"TreeMap","text":"<ul> <li>Schl\u00fcsselmenge in bin\u00e4rem Suchbaum</li> <li>funktioniert mit Comparable</li> </ul>"},{"location":"2022%20WS/04%20Collections/Map/#hashmap","title":"HashMap","text":"<ul> <li>Schl\u00fcsselmenge durch Hashing</li> </ul>"},{"location":"2022%20WS/04%20Collections/Set/","title":"Set","text":"<p>Sets/Mengen beinhalten keine doppelten Elemente.</p>"},{"location":"2022%20WS/04%20Collections/Set/#hashset","title":"HashSet","text":"<p>Implementiert Element-Eindeutigkeit mithilfe Hashings. - Vorteil: schnelles Einf\u00fcgen, L\u00f6schen und Suchen - Nachteil: Speicherverbrauch</p>"},{"location":"2022%20WS/04%20Collections/Set/#sortedset","title":"SortedSet","text":"<p>Sortieren mithilfe von Comparable-Schnittstelle. - Elemente sind Comparable - oder expliziten Comparator im Konstruktor \u00fcbergeben</p>"},{"location":"2022%20WS/04%20Collections/Set/#treeset","title":"TreeSet","text":"<p>Sortierung mithilfe eines balancierten bin\u00e4ren Suchbaums.</p>"},{"location":"2022%20WS/04%20Collections/Typisierung/","title":"Typisierung","text":""},{"location":"2022%20WS/04%20Collections/Typisierung/#typsicherheit","title":"Typsicherheit","text":"<p>Werden Typfehler sp\u00e4testens zur Laufzeit erkannt, spricht man von typsicheren Sprachen.</p> <ul> <li>keine Typverletzungen</li> <li>Typsicherheit zugestellt durch Compiler bzw. Interpreter</li> </ul>"},{"location":"2022%20WS/04%20Collections/Typisierung/#typprufung","title":"Typpr\u00fcfung","text":"<ul> <li>Verwendung von Datentypen innerhalb des Typsystems pr\u00fcfen</li> <li>Zuweisungen m\u00fcssen nicht dem exakten Typ entsprechen (z.B. <code>float zahl = 4;</code>)</li> <li>statisch typisiert: Typpr\u00fcfung w\u00e4hrend Kompilierung</li> <li>dynamisch typisiert: Typpr\u00fcfung prim\u00e4r zur Laufzeit</li> </ul>"},{"location":"2022%20WS/04%20Collections/Typisierung/#sprachen","title":"Sprachen","text":""},{"location":"2022%20WS/04%20Collections/Typisierung/#java","title":"Java","text":"<ul> <li>statisch: Typsicherheit von primitiven Datentypen bereits vom Bytecode-Compiler <code>javac</code> gepr\u00fcft</li> <li>dynamisch: l\u00e4sst dynamische Typpr\u00fcfungen durch <code>instanceof</code>-Operator zu</li> </ul>"},{"location":"2022%20WS/04%20Collections/Typisierung/#python-javascript-php-ruby","title":"Python, JavaScript, PHP, Ruby","text":"<ul> <li>vollst\u00e4ndig dynamisch typisiert</li> </ul>"},{"location":"2022%20WS/06%20Innere%20Klassen/Assoziation/","title":"Assoziation","text":""},{"location":"2022%20WS/06%20Innere%20Klassen/Assoziation/#beziehungen-zwischen-uml-klassen","title":"Beziehungen zwischen UML-Klassen","text":"<ul> <li>ungerichtet (kein Pfeil): \"nicht definiert\"</li> <li>gerichtet (1-2 Pfeilenden)</li> <li>reflexiv (auf sich selbst gerichtet)</li> </ul>"},{"location":"2022%20WS/06%20Innere%20Klassen/Assoziation/#spezielle-typen-von-assoziation","title":"Spezielle Typen von Assoziation","text":""},{"location":"2022%20WS/06%20Innere%20Klassen/Assoziation/#aggregation","title":"Aggregation","text":"<pre><code>public class Foo {\nprivate Bar bar;\nFoo(Bar bar) {\nthis.bar = bar;\n}\n}\n</code></pre>"},{"location":"2022%20WS/06%20Innere%20Klassen/Assoziation/#komposition","title":"Komposition","text":"<ul> <li>starke Form der Aggregation</li> <li>Teil-Objekt kann nicht ohne sein Komposit-Objekt existieren<ul> <li>darf also nicht nach au\u00dfen weitergegeben werden <pre><code>public class Foo {\nprivate Bar bar = new Bar();\nprivate class Bar{\n...\n}\n}\n</code></pre></li> </ul> </li> </ul> <pre><code>public class Foo {\nprivate Bar bar;\npublic Foo() {\nbar = new Bar(this);\n}\n}\n\nclass Bar {\nprivate Foo foo;\npublic Bar(Foo foo) {\nthis.foo = foo;\n}\n}\n</code></pre>"},{"location":"2022%20WS/06%20Innere%20Klassen/Innere%20Klassen/","title":"Innere Klassen","text":""},{"location":"2022%20WS/06%20Innere%20Klassen/Innere%20Klassen/#vorteile-von-inneren-klassen","title":"Vorteile von inneren Klassen","text":"<ul> <li>logische Gruppierung vereinfacht die Pakete</li> <li>erh\u00f6hte Verkapselung (kann private Felder der \u00e4u\u00dferen Klasse nutzen und ver\u00e4ndern)</li> <li>Code besser lesbar und wartbar (good practice)</li> </ul>"},{"location":"2022%20WS/06%20Innere%20Klassen/Innere%20Klassen/#statische-klassen","title":"Statische Klassen","text":"<ul> <li>K\u00f6nnen von \u00fcberall verwendet werden mithilfe von <code>A.B</code></li> </ul> <pre><code>public class Account {\nprivate int userId;\nprivate Permissions perm;\n\npublic Account(int userId) {\nthis.userId = userId;\nperm = new Permissions();\n}\n\npublic static class Permissions {\npublic boolean canRead;\npublic boolean canWrite;\npublic boolean canDelete; }\n\npublic Permissions getPermissions() { return perm; }\n}\n</code></pre> <pre><code>Account.Permissions = new Account.Permissions();\n</code></pre>"},{"location":"2022%20WS/06%20Innere%20Klassen/Innere%20Klassen/#instanzklassen","title":"Instanzklassen","text":"<ul> <li>K\u00f6nnen auf alle Eigenschaften einer Instanz zugreifen <pre><code>public interface Selector&lt;T&gt; {\nIterable&lt;T&gt; getItems();\n}\n\npublic class Sequence&lt;T&gt; {\nprivate List&lt;T&gt; items;\n\nprivate class SequenceSelector implements Selector {\n@Override\npublic Iterable&lt;T&gt; getItems() {\nreturn items; // Private member of Sequence\n}\n}\n\npublic Selector selector() {\nreturn new SequenceSelector();\n}\n}\n</code></pre></li> </ul>"},{"location":"2022%20WS/06%20Innere%20Klassen/Innere%20Klassen/#lokale-klassen","title":"Lokale Klassen","text":"<pre><code>class Math {\npublic static void calculate() {\n// Lokale innere klasse\nclass Differntial {\n...\n}\n\nvar diff = new Differential();\n}\n\n}\n</code></pre>"},{"location":"2022%20WS/06%20Innere%20Klassen/Innere%20Klassen/#anonyme-klassen","title":"Anonyme Klassen","text":"<pre><code>interface Callback {\nvoid call();\n}\n\nclass Delay {\npublic final Callback callback;\n\npublic Delay(Callback callback) {\nthis.callback = callback;\n}\n}\n\npublic static void main(String[] args) {\nvar delay = new Delay(new Callback() {\n@Override\nvoid call() {\nSystem.out.println(\"Done\");\n}\n});\n}\n</code></pre>"},{"location":"2022%20WS/06%20Innere%20Klassen/Innere%20Klassen/#python","title":"Python","text":"<pre><code>class Outer():\n    class Inner():\n        def __init__(self, name):\n            self.name = name\n\n    def __init__(self):\n        self.construct = Outer.Inner(\"Construct\")\n\n    def __str__(self):\n        return f\"Outer '{self.construct.name}'\"\n</code></pre>"},{"location":"2022%20WS/06%20Innere%20Klassen/Lambda/","title":"Lambda","text":"<p>Lambda = Anonyme Funktion</p>"},{"location":"2022%20WS/06%20Innere%20Klassen/Lambda/#java-7","title":"Java 7","text":"<pre><code>StateOwner stateOwner = new StateOwner();\nstateOwner.addStateListener(new StateChangeListener() {\npublic void onStateChange(State oldState, State newState) {\nSystem.out.println(\"State changed\");\n}\n});\n</code></pre>"},{"location":"2022%20WS/06%20Innere%20Klassen/Lambda/#java-8","title":"Java 8+","text":"<pre><code>StateOwner stateOwner = new StateOwner();\nstateOwner.addStateListener(\n(oldState, newState) -&gt; System.out.println(\"State changed\")\n);\n// ODER\nstateOwner.addStateListener((oldState, newState) -&gt; {\nSystem.out.println(\"State changed\");\n});\n</code></pre>"},{"location":"2022%20WS/06%20Innere%20Klassen/Lambda/#python","title":"Python","text":"<pre><code>lambda ARGS : COMPUTATION\n\ndef anonymous(ARGS):\n    COMPUTATION\n</code></pre>"},{"location":"2022%20WS/07%20Ausnahmen/Exceptions/","title":"Exceptions","text":""},{"location":"2022%20WS/07%20Ausnahmen/Exceptions/#hierarchie","title":"Hierarchie","text":"<ul> <li><code>Error</code> = Problem in der JVM<ul> <li>sollten nicht gecatcht werden</li> </ul> </li> <li><code>Exception</code> = Problem im Java-Code<ul> <li><code>RuntimeException</code>: Laufzeitfehler (k\u00f6nnen gecatcht werden)</li> <li>Andere: sollten gecatcht werden</li> </ul> </li> </ul> <pre><code>try {\nint ergebnis = 5 / 0; // wird Ausnahme werfen\n}\ncatch (ArithmeticException e) {\nSystem.out.println(\"Kann nicht durch 0 dividieren.\");\nthrow e; // rethrow\n}\nfinally {\n// \"Aufr\u00e4umarbeiten\"\n}\n</code></pre>"},{"location":"2022%20WS/08%20Streams%20und%20IO/Altklausuren/","title":"Altklausuren","text":""},{"location":"2022%20WS/08%20Streams%20und%20IO/Dateien/","title":"Dateien","text":"<p>Datei: Generell eine (unstrukturierte) Folge von Bytes. Dateizeiger: Byte-Position, an der aktuell gelesen/geschrieben wird.</p>"},{"location":"2022%20WS/08%20Streams%20und%20IO/Dateien/#operationen","title":"Operationen","text":"<p>Dateien m\u00fcssen \"ge\u00f6ffnet\" sein, um Daten lesen und schreiben zu k\u00f6nnen. Danach m\u00fcssen sie wieder \"geschlossen\" werden.</p> <ul> <li>\u00d6ffnen - \"open\"<ul> <li>Es wird ein sogenannter Dateipuffer eingerichtet, um schneller auf die Daten einer Datei zugreifen zu k\u00f6nnen</li> </ul> </li> <li>Lesen - \"read\" (Bytes werden aus einer Datei geladen)<ul> <li>Es ist nicht m\u00f6glich, den Dateizeiger \u00fcber das Ende der Datei (EOF = End-of-File) hinaus zu schieben.</li> </ul> </li> <li>Schreiben - \"write\" (Bytes werden in einer Datei ver\u00e4ndert)<ul> <li>Wenn der Dateizeiger hinter EOF positioniert ist, werden Daten an eine Datei angeh\u00e4ngt.</li> </ul> </li> <li>Suchen - \"seek\" (Die Position des Dateizeigers wird ver\u00e4ndert)</li> <li>Schlie\u00dfen - \"close\"<ul> <li>Speichert die ge\u00e4nderten Daten schlie\u00dflich auf der Festplatte.</li> </ul> </li> </ul>"},{"location":"2022%20WS/08%20Streams%20und%20IO/Dateien/#in-java","title":"In Java","text":"<p>Datei-Operationen werden durch zwei spezielle Streams erm\u00f6glicht.</p> <ol> <li><code>FileInputStream</code> - Aus dem Strom k\u00f6nnen Daten entnommen/gelesen werden</li> <li><code>FileOutputStream</code> - In den Strom k\u00f6nnen Daten hinzugef\u00fcgt/geschrieben werden.</li> </ol> <p>Bei Textdateien sollten bestimmte Klassen genutzt werden.</p> <p><pre><code>public static void main(String[] args) throws IOException {\n// \"open\"\n// DATEISTR\u00d6ME f\u00fcr die EIN- und AUSGABE werden erzeugt.\nFileInputStream in = new FileInputStream(\"datei.txt\");\nFileOutputStream out = new FileOutputStream(\"kopierte_datei.txt\");\n\n// \"read\"\n// Der erste Byte wird aus der Warteschlange des EINGABE-STROMS entnommen.\nint dataByte = in.read();\n\nwhile (b != -1) {\n// \"write\"\n// Der gelesene Byte wird in die Warteschlange des AUSGABE-STROMS hinzugef\u00fcgt.\nout.write(b);\n\n// \"read\"\n// Der n\u00e4chste Byte wird aus dem EINGABE-STROM entnommen.\nb = in.read();\n}\n\n// \"close\"\n// Dateioperationen sind fertig - Alle Streams sollten GESCHLOSSEN werden.\nin.close();\nout.close();\n}\n</code></pre> Beispiel: Die Datei \"datei.txt\" wird in eine andere Datei \"kopierte_datei.txt\" kopiert.</p>"},{"location":"2022%20WS/08%20Streams%20und%20IO/JSON/","title":"JSON","text":"<p>JavaScript Object Notation.</p> <ul> <li>Sehr leicht von Menschen (und unterschiedlichen Anwendungen) lesbar</li> <li>Kann auch von Java geschrieben und gelesen werden mit dem Package <code>org.json</code></li> </ul> <pre><code>{\n\"employees\": [\n{\n\"firstName\": \"John\",\n\"lastName\": \"Doe\"\n},\n{\n\"firstName\": \"Anna\",\n\"lastName\": \"Smith\"\n},\n{\n\"firstName\": \"Peter\",\n\"lastName\": \"Jones\"\n}\n]\n}\n</code></pre>"},{"location":"2022%20WS/08%20Streams%20und%20IO/Serialisierung/","title":"Serialisierung","text":"<p>Das Konvertieren von einem Objekt --&gt; Bytes, die z.B. auf der Festplatte gespeichert werden k\u00f6nnen.</p> <p>Die gelagerten Bytes k\u00f6nnen danach wieder deserialisiert werden (Bytes --&gt; Objekt).</p>"},{"location":"2022%20WS/08%20Streams%20und%20IO/Serialisierung/#algorithmus-der-serialisierung","title":"Algorithmus der Serialisierung","text":"<p>Algorithmus, um ein bestimmtes Objekt in Bytes zu verwandeln.</p> <ol> <li>Erzeuge und Schreiben einer ID (\"eindeutige Seriennummer\") f\u00fcr das Objekt</li> <li>Schreiben der Klasseneigenschaften (Klassenname, Attributnamen und -typen)</li> <li>Schreiben der Attributwerte<ol> <li>Falls es sich um einen primitiven Typen handelt, schreibe ihn direkt</li> <li>Falls es sich um eine Referenz handelt...<ol> <li>Falls die Referenz noch nicht serialisiert ist: Serialisiere die Referenz (rekursiv!)</li> <li>Falls die Referenz bereits geschrieben wurde, schreibe ihre ID</li> </ol> </li> </ol> </li> </ol> <p>Eine Klasse ist nur serialisierbar, wenn... 1. Sie das Marker-Interface <code>Serializable</code> implementiert 2. In ihren Attributen ausschlie\u00dflich primitive Datentypen und serialisierbare Objekte stehen</p>"},{"location":"2022%20WS/08%20Streams%20und%20IO/Serialisierung/#de-serialisierung-mit-datenstrom","title":"(De-)Serialisierung mit Datenstrom","text":"<p>In Java k\u00f6nnen serialisierbare Objekte mithilfe von <code>ObjectOutputStream</code> in einen Byte-Datenstrom konvertiert werden.</p> <pre><code>class ObjectOutputStream {\n// Konstruktor\nObjectOutputStream(OutputStream stream) throws IOException {...}\n\n// Schreibt \"obj\" in den Strom\nvoid writeObject(Serializable obj) throws IOException {...}\n\n// Setzt alle Referenzen zur\u00fcck, die bereits geschriebenen wurden\nvoid reset() throws IOException {...}\n}\n</code></pre> <p>Zum Deserialisieren kann die Klasse <code>ObjectInputStream</code> benutzt werden.</p> <pre><code>class ObjectInputStream {\n// Konstruktor\nObjectInputStream(InputStream in) throws IOException {...}\n\n// Liest das n\u00e4chste Objekt aus dem Byte-Datenstrom und gibt es zur\u00fcck\nObject readObject() throws IOException {...}\n}\n</code></pre> <p>Beispiel: <pre><code>// Speichert einen Studenten in die Datei \"savefile.ser\"\npublic void writeStudentToFile() {\nObjectOutputStream objectStream;\n\ntry {\nStudent s = new Student(\"Hugo\", \"Test\", 12345678);\ns.setNote(1.3);\n\nFileOutputStream fileStream = new FileOutputStream(\"savefile.ser\");\nobjectStream = new ObjectOutputStream(fileStream);\nobjectStream.writeObject(s);\n} finally {\nobjectStream.close();\n}\n}\n\n// Liest das erste Objekt aus der Datei \"savefile.ser\" und gibt es zur\u00fcck\npublic Student readStudentFromFile() {\nObjectInputStream objectStream;\n\ntry {\nFileInputStream fileStream = new FileInputStream(\"savefile.ser\");\nobjectStream = new ObjectInputStream(fileStream);\n\nObject deserialized = objectStream.readObject();\nreturn (Student) deserialized; // Explizites Downcasting\n} finally {\nobjectStream.close();\n}\n}\n</code></pre></p>"},{"location":"2022%20WS/08%20Streams%20und%20IO/Serialisierung/#grenzen-der-serialisierung","title":"Grenzen der Serialisierung","text":"<ul> <li>Wenn der Quellcode einer Klasse abge\u00e4ndert wird, k\u00f6nnen vorher gespeicherte Bytes nicht mehr in die Klasse konvertiert werden.</li> <li>Aus gespeicherten Bytes k\u00f6nnen andere Anwendungen nur sehr schwer die Daten importieren.</li> </ul>"},{"location":"2022%20WS/08%20Streams%20und%20IO/Standard-Datenstr%C3%B6me/","title":"Standard-Datenstr\u00f6me","text":"<p>In Java gibt es 3 Standard-Datenstr\u00f6me f\u00fcr die Ein-/Ausgabe von Nachrichten in der Konsole.</p>"},{"location":"2022%20WS/08%20Streams%20und%20IO/Standard-Datenstr%C3%B6me/#input","title":"Input","text":"<p>Der Standard-Datenstrom <code>System.in</code> kann Nachrichten verarbeiten, die in der Konsole eingegeben werden.</p>"},{"location":"2022%20WS/08%20Streams%20und%20IO/Standard-Datenstr%C3%B6me/#output","title":"Output","text":"<p>Die normale Ausgabe von <code>println</code>-Befehlen funktioniert \u00fcber den Datenstrom <code>System.out</code> in Java.</p> <p>Fehlernachrichten und Ausnahmen werden \u00fcber einen weiteren Datenstrom namens <code>System.err</code> ausgegeben. Diese Nachrichten werden in der Konsole in roter Farbe angezeigt.</p> <pre><code>// EINGABE\nSystem.in.read(...);\n\n// AUSGABE (NACHRICHTEN)\nSystem.out.println(\"Hello World\");\n\n// AUSGABE (FEHLER)\nSystem.err.println(\"Fehler!!!\");\n</code></pre>"},{"location":"2022%20WS/08%20Streams%20und%20IO/Streams/","title":"Streams","text":"<p>Ein Stream ist eine Datenstruktur \u00e4hnlich wie eine Queue/Warteschlange.</p> <p>Streams besitzen zwei Seiten: 1. Quelle: Hier werden Daten in die Queue hinzugef\u00fcgt. 2. Senke: Hier werden Daten aus der Queue entfernt.</p> <p></p> <p>In Java werden Streams f\u00fcr verschiedene Operationen verwendet.</p> <ol> <li>Ein-/Ausgabe \u00fcber die Konsole (Standard-Datenstr\u00f6me <code>System.in</code>/<code>System.out</code>/<code>System.err</code>)</li> <li>Laden/Speichern von Dateien (<code>FileInputStream</code>, <code>FileOutputStream</code>)</li> </ol>"},{"location":"2022%20WS/08%20Streams%20und%20IO/Textdateien/","title":"Textdateien","text":"<p>Zum Lesen/Schreiben einer Textdatei sollten in Java bestimmte Klassen verwendet werden:</p> <ol> <li><code>BufferedReader</code> - erm\u00f6glicht das Lesen einzelner Textzeilen</li> <li><code>PrintWriter</code> - erm\u00f6glicht das formatierte Schreiben von Daten/Objekten</li> </ol>"},{"location":"2022%20WS/09%20Datenstrukturen/B%C3%A4ume/","title":"B\u00e4ume","text":"<p>Von einem Wurzelknoten ausgehend hat ein Baum untergeordnete Kinderknoten.</p>"},{"location":"2022%20WS/09%20Datenstrukturen/B%C3%A4ume/#traversierung","title":"Traversierung","text":"<pre><code>   M\n /   \\\nL     R\n</code></pre> <ul> <li>Breadth-First (Breiten-Traversierung)<ul> <li>Realisiert durch Queue</li> </ul> </li> <li>Depth-First (Tiefen-Traversierung)<ul> <li>In Order ( L M R )</li> <li>Pre Order ( M L R )</li> <li>Post Order ( L R M )</li> <li>Realisiert durch Stack</li> </ul> </li> </ul>"},{"location":"2022%20WS/09%20Datenstrukturen/B%C3%A4ume/#binarer-suchbaum-bst","title":"Bin\u00e4rer Suchbaum (BST)","text":"<p>Ein bin\u00e4rer Suchbaum hat folgende Eigenschaften:</p> <ul> <li>Jeder Knoten hat maximal 2 Kinder (\"links\" und \"rechts\")</li> <li>F\u00fcr einen Knoten mit Wert N gilt<ul> <li>Alle untergeordneten Knoten auf der linken Seite haben einen Wert \u2264 N</li> <li>Alle untergeordneten Knoten auf der rechten Seite haben einen Wert \u2265 N</li> <li>Dadurch bleibt ein bin\u00e4rer Suchbaum immer sortiert</li> </ul> </li> </ul>"},{"location":"2022%20WS/09%20Datenstrukturen/Graphen/","title":"Graphen","text":"<p>Siehe Graph.</p> <p>Weitere Eigenschaften eines Graphen:</p> <ul> <li>Grad/Valenz - Anzahl der verbundenen Kanten an einem Knoten<ul> <li>Gerichtete Graphen haben dabei Eingangsgrad und Ausgangsgrad</li> </ul> </li> <li>Ein Graph hei\u00dft \"regul\u00e4r\", wenn alle Knoten denselben Grad haben</li> <li>Gewichtete Graphen</li> </ul>"},{"location":"2022%20WS/09%20Datenstrukturen/Graphen/#untergraphen-und-teilgraphen","title":"Untergraphen und Teilgraphen","text":"<p>Sei G ein Graph. G kann als \"Obergraph\" bezeichnet werden. Wenn Knoten oder Kanten aus diesem Obergraph entfernt werden, bildet sich ein neuer Teilgraph von G.</p> <p>Spezieller Fall \"Untergraph\" - Es werden Knoten aus dem Obergraphen entfernt, aber so viele Kanten wie m\u00f6glich beibehalten.</p>"},{"location":"2022%20WS/09%20Datenstrukturen/Graphen/#wege-und-pfade","title":"Wege und Pfade","text":"<p>Ein Weg ist eine Aneinanderreihung von Knoten, die jeweils durch Kanten verbunden sind.</p> <p>Spezieller Fall \"Pfad\" - Es gibt keine doppelten Knoten in der Aneinanderreihung. Spzieller Fall \"Eulerscher Weg\" - Es werden alle Kanten verwendet. Falls der Endknoten gleichzeitig auch der Startknoten ist, spricht man von einem \"Eulerschen Kreis\".</p>"},{"location":"2022%20WS/09%20Datenstrukturen/Graphen/#traversierung","title":"Traversierung","text":"<p>Graphen k\u00f6nnen im Gegensatz zu B\u00e4umen sogenannte Zyklen enthalten.</p> <ul> <li>Breitensuche - Umgesetzt durch Queue</li> <li>Tiefensuche - Umgesetzt durch Stack</li> </ul>"},{"location":"2022%20WS/09%20Datenstrukturen/Graphen/#umsetzung","title":"Umsetzung","text":"<ul> <li>Adjazenzliste - Pro Knoten werden die verbundenen Endknoten gespeichert<ul> <li>Statische Adjazenzliste - Nutzung von Arrays</li> <li>Dynamische Adjazenzliste - Nutzung von Linked Lists</li> </ul> </li> <li>Adjazenzmatrix - 2-dimensionelles Array (abbildende \"Tabelle\") zur Beschreibung von Kanten</li> </ul>"},{"location":"2022%20WS/09%20Datenstrukturen/Weitere%20Listen/","title":"Weitere Listen","text":"<p>Verschiedene Typen von Listen.</p>"},{"location":"2022%20WS/09%20Datenstrukturen/Weitere%20Listen/#linked-list","title":"Linked List","text":"<p>Eine Linked List beinhaltet nur eine Referenz auf das erste Element (\"head\"). Dieses Element kann dann auf den n\u00e4chsten Eintrag in der Liste verweisen.</p>"},{"location":"2022%20WS/09%20Datenstrukturen/Weitere%20Listen/#doppelte-linked-list","title":"Doppelte Linked List","text":"<p>Eine #Linked List, wobei jedes Element der Liste beinhaltet eine Referenz auf das n\u00e4chste Element und das vorherige Element.</p>"},{"location":"2022%20WS/09%20Datenstrukturen/Weitere%20Listen/#circular-linked-list","title":"Circular Linked List","text":"<p>Eine Circular Linked List ist ein geschlossener \"Ring\" von Elementen.</p> <ul> <li>Das letzte Element der Liste zeigt wieder auf das erste Element</li> <li>Kann mit #Linked List oder #Doppelte Linked List umgesetzt werden</li> </ul>"},{"location":"2022%20WS/09%20Datenstrukturen/Weitere%20Listen/#stack","title":"Stack","text":"<p>Implementiert LIFO (\"Last in, first out\").</p> <ul> <li><code>push(&lt;ELEMENT&gt;)</code> - Element auf den Stack legen</li> <li><code>pop()</code> - Oberstes Element aus dem Stack entnehmen</li> <li><code>peek() / top()</code> - Oberstes Element aus dem Stack zur\u00fcckgeben, aber nicht entnehmen</li> </ul>"},{"location":"2022%20WS/09%20Datenstrukturen/Weitere%20Listen/#queue","title":"Queue","text":"<p>Implementiert FIFO (\"First in, first out\").</p> <ul> <li><code>enqueue(&lt;ELEMENT&gt;)</code> - Element an das Ende der Queue anh\u00e4ngen</li> <li><code>dequeue()</code> - Vorderstes Element aus der Queue entnehmen</li> <li><code>front()</code> - Vorderstes Element zur\u00fcckgeben, aber nicht entnehmen</li> <li><code>rear()</code> - Hinterstes Element zur\u00fcckgeben</li> </ul>"},{"location":"2022%20WS/10%20Hashing/Hashing/","title":"Hashing","text":"<p>Hashfunktionen und deren Anwendung.</p> <p>Anwendungen</p> <ul> <li>Pr\u00fcfsummen - Schnelles \u00dcberpr\u00fcfen der Richtigkeit von ISBN oder Kontonummern durch Modulorechnung</li> <li>Kryptologie - Einseitiges Verschl\u00fcsseln von Passw\u00f6rtern</li> </ul> <p>Kriterien f\u00fcr einen guten Hashalgorithmus 1. Streuung - M\u00f6glichst gleichverteilte Hashwerte f\u00fcr erwartete Eingaben (weniger Kollisionen) 2. Datenreduktion - Ein Hashwert soll weniger Speicher verbrauchen als die Eingabe 3. Chaos - M\u00f6glichst verschiedene Hashwerte f\u00fcr \u00e4hnliche Eingaben     - \u00c4ndern eines einzigen Eingabe-Bits sollte durchschnittlich die H\u00e4lfte aller Hashwert-Bits ver\u00e4ndern 4. Surjektivit\u00e4t - M\u00f6glichst viele theoretische Hashwerte 5. Effizienz - M\u00f6glichst schnell zu berechnen 6. Ordnungserhaltend - Bei sortiertem Zugriff auf Hashtabelle</p>"},{"location":"2022%20WS/11%20Backtracking/Algorithmus/","title":"Algorithmus","text":"<p>Ein Algorithmus beschreibt, wie ein konkretes Problem gel\u00f6st werden soll \u2013 und zwar exakt. Er besteht aus einer endlichen Abfolge von Anweisungen.</p> <p>Erforderliche Eigenschaften</p> <ol> <li>Finit - Mit endlichem Text eindeutig beschreibbar</li> <li>Dynamisch finit - Endlicher Speicherbedarf</li> <li>Ausf\u00fchrbar - Jeder Schritt muss ausf\u00fchrbar sein</li> <li>Terminierend - Es werden nur endliche Schritte ben\u00f6tigt</li> </ol> <p>Weitere m\u00f6gliche Eigenschaften</p> <ol> <li>Determiniertheit - Gleiche Eingabe liefert immer das gleiche Ergebnis</li> <li>Deterministisch - Der n\u00e4chste Programmschritt ist immer eindeutig definiert</li> </ol>"},{"location":"2022%20WS/11%20Backtracking/Algorithmus/#strategien","title":"Strategien","text":"<p>Algorithmen nach Strategien kategorisiert.</p> <ol> <li>Brute Force - Alle m\u00f6glichen L\u00f6sungen unintelligent generieren und alle versuchen</li> <li>Backtracking - Systematisch und schrittweise (vor und zur\u00fcck) m\u00f6gliche L\u00f6sungen generieren</li> <li>Divide and Conquer - Problem rekursiv in unabh\u00e4ngige Unterprobleme teilen und dann zusammenf\u00fcgen</li> <li>Dynamische Programmierung - Optimierungsproblem rekursiv in \u00fcberlappende Unterprobleme teilen und dann zusammenf\u00fcgen</li> <li>Greedy - Immer den n\u00e4chstbesten Schritt ohne zur\u00fcckzugehen</li> <li>Branch and Bound - Backtracking bei Optimierungsproblemen</li> <li>Hill Climbing - Optimierungsproblem durch evolution\u00e4re Verbesserungen l\u00f6sen</li> <li>Particle Swarm - Dezentalisierte \"Partikel\", die organisiert auf unterschiedliche Weise eine L\u00f6sung suchen</li> </ol>"},{"location":"2022%20WS/11%20Backtracking/Backtracking/","title":"Backtracking","text":"<p>Backtracking funktioniert wie Tiefensuche in einem Baum. Es werden alle n\u00e4chsten Schritte (Kindknoten) betrachtet und der erste \"m\u00f6gliche\" Schritt genommen. Falls ein Schritt als \"unm\u00f6glich\" markiert ist, wird r\u00fcckg\u00e4ngig gegangen und der n\u00e4chste Schritt \u00fcberpr\u00fcft.</p> <p>Anwendung oft bei Spielen wie Schach oder Sudoku.</p> <p></p>"},{"location":"2022%20WS/12%20Greedy/Dijkstra-Algorithmus/","title":"Dijkstra-Algorithmus","text":"<p>Der Dijkstra-Algorithmus findet die k\u00fcrzesten Pfade von einem gew\u00e4hlten Startknoten zu allen anderen Knoten eines Graphen.</p> <p>Zu jedem Knoten werden zwei Dinge gespeichert.</p> <ul> <li>Die Pfadl\u00e4nge zum Startknoten (anfangs \\(\\infty\\))</li> <li> <p>Der Vorl\u00e4ufer-Knoten in seinem Pfad (anfangs <code>null</code>)</p> </li> <li> <p>Setze die Pfadl\u00e4nge des Startknoten auf 0</p> </li> <li>Schleife: bis keine Knoten mehr \u00fcbrig sind<ol> <li>Entnehme den Knoten mit der kleinsten Pfadl\u00e4nge (\"Priority Queue\")</li> <li>Schleife: f\u00fcr alle anschlie\u00dfenden Kanten des entnommenen Knoten<ol> <li>Sei \\(w\\) = (Pfadl\u00e4nge des entnommenen Knoten + Gewicht der Kante)</li> <li>Falls \\(w\\) &lt; Pfadl\u00e4nge des anderen Knoten:<ol> <li>Setze die Pfadl\u00e4nge des anderen Knoten auf \\(w\\)</li> <li>Trage als Vorl\u00e4ufer des anderen Knoten den entnommenen Knoten ein</li> </ol> </li> </ol> </li> </ol> </li> </ul> <p></p> Iteration Betrachteter Knoten Pfadl\u00e4nge und Vorl\u00e4ufer der jeweiligen Knoten 0 - <code>s( 0,- ) t( \u221e,-) x( \u221e,-) y( \u221e,-) z( \u221e,-)</code> 1 s <code>-------- t(10,s) x( \u221e,-) y( 5,s) z( \u221e,-)</code> 2 y <code>-------- t( 8,s) x(14,y) ------- z( 7,y)</code> 3 z <code>-------- t( 8,s) x(13,y) ------- -------</code> 4 t <code>-------- ------- x( 9,y) ------- -------</code> <p>Am Ende beinhaltet jeder Knoten des Graphen die minmale Pfadl\u00e4nge zum Startknoten und den jeweiligen Vorl\u00e4ufer-Knoten seines minimalen Pfades.</p>"},{"location":"2022%20WS/12%20Greedy/Greedy/","title":"Greedy","text":"<p>Greedy-Algorithmen nehmen immer die Entscheidung, die in dem Moment am besten aussieht.</p> <p>Im Gegensatz zu Backtracking gehen Greedy-Algorithmen nie R\u00fcckw\u00e4rtsschritte.</p> <p>Anwendung in Graph-Algorithmen - Minimalen Spannbaum (MST) berechnen - Kruskal, Prim - K\u00fcrzesten Weg finden - Dijkstra</p>"},{"location":"2022%20WS/12%20Greedy/Komplexit%C3%A4tsberechnung/","title":"Komplexit\u00e4tsberechnung","text":"<p>Es gibt drei Methoden zur Komplexit\u00e4tsberechnung bei Rekursionen.</p>"},{"location":"2022%20WS/12%20Greedy/Komplexit%C3%A4tsberechnung/#substitution-induktion","title":"Substitution (Induktion)","text":"<p>Aus den Laufzeit-Komponenten eines Algorithmus wird eine rekursive Funktion gebildet. Aus dieser Funktion wird eine Komplexit\u00e4t eingesch\u00e4tzt und dann induktiv bewiesen.</p> <ul> <li>Rekursive Formel: z.B. \\(T(n) = 2T(n/2) + n\\)</li> <li>Gesch\u00e4tzte Komplexit\u00e4t der Formel: \\(\\Theta(n \\log{n})\\)</li> <li>Induktion: Beweisen von \\(T(n) \\leq c * n \\log{n}\\) (Komplexit\u00e4t multipliziert mit einer Konstante)</li> </ul>"},{"location":"2022%20WS/12%20Greedy/Komplexit%C3%A4tsberechnung/#rekurrenzbaum","title":"Rekurrenzbaum","text":"<p>Darstellung der Teilprobleme als einzelne Knoten eines Baums. Jeder Teilproblem-Knoten ist beschriftet mit seinem \"Arbeitsaufwand\" (Komplexit\u00e4t).</p> <ul> <li>Die Komplexit\u00e4t von Bl\u00e4ttern ist \\(\\Theta(1)\\)</li> <li>Gesamtkomplexit\u00e4t durch Addition aller Knoten</li> </ul> <p></p>"},{"location":"2022%20WS/12%20Greedy/Komplexit%C3%A4tsberechnung/#master-theorem","title":"Master-Theorem","text":"<p>Diese Methode kann nur genutzt werden, falls der rekursive Algorithmus die folgende Form. \\(\\(T(n) = a * T(n/b) + f(n)\\)\\) Komponenten seien dabei</p> <ul> <li>Anzahl der Teilprobleme pro Rekursionsschritt: \\(a \\geq 1\\)</li> <li>Teilung des Inputs pro Teilrekursion: \\(b &gt; 1\\)</li> </ul> <p>Dann wird zwischen drei F\u00e4llen unterschieden, abh\u00e4ngig von der Komplexit\u00e4t von \\(f(n)\\). \\(\\(f(n) = \\Theta(n^c)\\)\\)</p> <ol> <li>\\(c &lt; \\log_b a \\implies T(n) = \\Theta(n^{\\log_b a})\\)</li> <li>\\(c = \\log_b a \\implies T(n) = \\Theta(n^c * \\log{n})\\)</li> <li>\\(c &gt; \\log_b a \\implies T(n) = f(n)\\)</li> </ol>"},{"location":"2022%20WS/12%20Greedy/Minimaler%20Spannbaum/","title":"Minimaler Spannbaum","text":"<p>Spannbaum - Eine Baum-Struktur, die aus einem gewichteten Graphen entsteht.</p> <p>Ein Spannbaum hei\u00dft \"minimal\", wenn er alle Knoten beinhaltet und die Kanten mit dem kleinstm\u00f6glichen Gesamtgewicht \u00fcbertr\u00e4gt.</p>"},{"location":"2022%20WS/12%20Greedy/Minimaler%20Spannbaum/#kruskal-algorithmus","title":"Kruskal-Algorithmus","text":"<p>Kanten von kleinstem zu gr\u00f6\u00dftem Gewicht sortieren und der Reihenfolge nach in einen Baum \u00fcbertragen.</p> <p>Zyklen m\u00fcssen explizit durch Find-Union vermieden werden. - Alle Knoten besitzen am Anfang eine Menge, die nur den einzelnen Knoten beinhaltet. - Mit jeder eingetragenen Kante werden die Mengen beider Knoten vereint. - Eine Kante wird \u00fcbersprungen, falls beide Knoten dieselbe Menge besitzen (sonst w\u00fcrde ein Zyklus entstehen).</p> <ol> <li>Alle Kanten des Graphen von kleinstem zu gr\u00f6\u00dftem Gewicht sortieren</li> <li>Schleife: alle Kanten der Reihenfolge nach<ol> <li>\u00dcberpr\u00fcfen, ob die beiden Knoten der Kante schon in Verbindung stehen (\"Find-Union\")</li> <li>Falls nicht: Kante eintragen</li> </ol> </li> </ol> <p></p>"},{"location":"2022%20WS/12%20Greedy/Minimaler%20Spannbaum/#prim-algorithmus","title":"Prim-Algorithmus","text":"<ol> <li>Ein Startknoten wird gew\u00e4hlt und als besucht markiert</li> <li>Schleife: bis alle Knoten besucht sind<ol> <li>Erreichbare Kanten = Alle Kanten, die von allen besuchten Knoten ausgehen und zu unbesuchten Knoten f\u00fchren</li> <li>Aus den erreichbaren Kanten wird die mit dem kleinsten Gewicht gew\u00e4hlt</li> <li>Die gew\u00e4hlte Kante wird eingetragen und der neue Knoten als besucht markiert</li> </ol> </li> </ol>"}]}