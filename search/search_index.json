{"config":{"lang":["de"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Einleitung","text":"<p>Gesammelte Notizen zu den Vorlesungen Informatik I (SoSe 22), Informatik II (WiSe 22) und Informatik III (SoSe 23).</p> <p>Unter 2023 SS sind Themen des aktuellen Semesters zusammengefasst.</p>"},{"location":"2022%20SS/B%C3%A4ume/Balancierte%20B%C3%A4ume/","title":"Balancierte B\u00e4ume","text":""},{"location":"2022%20SS/B%C3%A4ume/Balancierte%20B%C3%A4ume/#eigenschaften","title":"Eigenschaften","text":"<ul> <li>Alle \u00c4ste (fast) gleich lang</li> <li>Kann in bin\u00e4ren Suchb\u00e4umen nicht erzwungen werden</li> <li>Nicht-balancierte B\u00e4ume nennt man entartete B\u00e4ume</li> </ul>"},{"location":"2022%20SS/B%C3%A4ume/Balancierte%20B%C3%A4ume/#rot-schwarz-baum","title":"Rot-Schwarz-Baum","text":"<ol> <li>Jeder Knoten ist entweder schwarz oder rot</li> <li>(Die Wurzel ist schwarz)</li> <li>Alle Bl\u00e4tter sind schwarz</li> <li>Die Kinder eines roten Knoten sind schwarz</li> <li> <p>Jeder Pfad von Knoten zu allen Bl\u00e4ttern enth\u00e4lt gleich viele schwarze Knoten</p> </li> <li> <p>Laufzeitkomplexit\u00e4t bei Einf\u00fcgen und L\u00f6schen h\u00f6her als bei bin\u00e4ren Suchb\u00e4umen</p> </li> <li>Suche ist f\u00fcr alle Eingabesequenzen garantiert <code>O(lg n)</code></li> </ol> <p>https://www.happycoders.eu/de/algorithmen/rot-schwarz-baum-java/</p>"},{"location":"2022%20SS/B%C3%A4ume/Balancierte%20B%C3%A4ume/#einfugen","title":"Einf\u00fcgen","text":"<ul> <li>Eingef\u00fcgte Knoten sind immer rot</li> <li>Falls Vater schwarz: fertig</li> <li>Falls Vater rot:<ul> <li>Umf\u00e4rben (Vater, Onkel, Gro\u00dfvater)</li> <li>Schleife: Hoch traversieren<ul> <li>Falls Onkel schwarz:<ul> <li>Falls rechtes Kind<ul> <li>Rotate-Left (Vater)</li> </ul> </li> <li>Falls linkes Kind<ul> <li>Rotate-Right (Gro\u00dfvater)</li> <li>Umf\u00e4rben (Vater, Gro\u00dfvater)</li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"2022%20SS/B%C3%A4ume/Balancierte%20B%C3%A4ume/#loschen","title":"L\u00f6schen","text":""},{"location":"2022%20SS/B%C3%A4ume/Balancierte%20B%C3%A4ume/#rotate","title":"Rotate","text":"<ul> <li>rotate-left<ul> <li>parent becomes left child</li> <li>left child becomes parent's right child</li> </ul> </li> <li>rotate-right<ul> <li>parent becomes right child</li> <li>right child becomes parent's left child</li> </ul> </li> </ul> <pre><code>  20                [40]                       40                [20]\n/  \\               /  \\                      /  \\               /  \\  10 [40]    --&gt;    20    50                  [20]  50    --&gt;    10    40\n/  \\          /  \\                       /  \\                    /  \\     30  50        10  30                     10  30                  30  50    </code></pre>"},{"location":"2022%20SS/B%C3%A4ume/Baum/","title":"Baum","text":""},{"location":"2022%20SS/B%C3%A4ume/Baum/#eigenschaften","title":"Eigenschaften","text":"<ul> <li>Zwischen zwei Knoten gibt es genau einen Weg</li> <li>Es gibt immer eine Kante weniger als Knoten</li> <li>Der Graph ist minimal zusammenh\u00e4ngend (?)</li> <li> <p>Keine Zyklen</p> </li> <li> <p>Entfernt man eine Kante, entstehen zwei Teilb\u00e4ume (Wald)</p> </li> <li>Verbindet man die Wurzeln zweier gerichteter B\u00e4ume, entsteht ein neuer Baum</li> </ul>"},{"location":"2022%20SS/B%C3%A4ume/Baum/#ungerichtete-baume","title":"Ungerichtete B\u00e4ume","text":"<ul> <li>Zusammenh\u00e4ngender, kreisfreier ungerichteter Graph</li> <li>Knoten mit Grad 1 hei\u00dfen Bl\u00e4tter</li> </ul>"},{"location":"2022%20SS/B%C3%A4ume/Baum/#gerichtete-baume","title":"Gerichtete B\u00e4ume","text":"<ul> <li>Gerichteter kreisfreier Graph</li> <li>Genau eine Wurzel mit Eingangsgrad 0</li> <li>Knoten mit Ausgangsgrad 0 hei\u00dfen Bl\u00e4tter</li> </ul>"},{"location":"2022%20SS/B%C3%A4ume/Baum/#wald","title":"Wald","text":"<ul> <li>Mehrere B\u00e4ume/Wurzeln</li> </ul>"},{"location":"2022%20SS/B%C3%A4ume/Baum/#hohetiefe-eines-baums","title":"H\u00f6he/Tiefe eines Baums","text":"<ul> <li>Leerer Baum hat keine Wurzel, H\u00f6he 0</li> <li>Wurzel hat Tiefe 0, H\u00f6he 1</li> </ul>"},{"location":"2022%20SS/B%C3%A4ume/Baum/#binarer-baum","title":"Bin\u00e4rer Baum","text":"<ul> <li>Ein leerer Baum</li> <li>Sind L und R zwei bin\u00e4re B\u00e4ume, lassen sie sich durch einen einzelnen Knoten zu einem neuen bin\u00e4ren Baum zusammenf\u00fcgen</li> </ul>"},{"location":"2022%20SS/B%C3%A4ume/Baum/#binarer-suchbaum","title":"Bin\u00e4rer Suchbaum","text":"<ul> <li>Beide Unterb\u00e4ume sind bin\u00e4re Suchb\u00e4ume</li> <li>Werte des linken Baums sind kleiner als Wurzelbeschriftung</li> <li>Werte des rechten Baums sind gr\u00f6\u00dfer als Wurzelbeschriftung</li> </ul>"},{"location":"2022%20SS/B%C3%A4ume/Baum/#voller-saturierter-baum","title":"Voller (saturierter) Baum","text":"<ul> <li>Jeder Knoten besitzt 0 oder 2 Kinder</li> </ul>"},{"location":"2022%20SS/B%C3%A4ume/Baum/#vollstandiger-baum","title":"Vollst\u00e4ndiger Baum","text":"<ul> <li>Alle Bl\u00e4tter haben dieselbe Tiefe</li> </ul>"},{"location":"2022%20SS/B%C3%A4ume/Baum/#vollstandiger-binarbaum-hohe-h","title":"Vollst\u00e4ndiger Bin\u00e4rbaum (H\u00f6he h)","text":"<ul> <li>\\(2^h-1\\) Knoten</li> <li>\\(2^{h-1} - 1\\) innere Knoten</li> <li>\\(2^t\\) Knoten in Tiefe t (\\(0 \\leq t \\leq h-1\\))</li> <li>\\(2^{h-1}\\) Bl\u00e4tter</li> </ul>"},{"location":"2022%20SS/B%C3%A4ume/Traversierung/","title":"Traversierung","text":""},{"location":"2022%20SS/B%C3%A4ume/Traversierung/#tiefensuche-depth-first","title":"Tiefensuche (depth-first)","text":"<ul> <li>Pre-order (Hauptreihenfolge): <code>W-l-r</code></li> <li>Post-order (Nebenreihenfolge): <code>l-r-W</code></li> <li>In-order (symmetrische Reihenfolge): <code>l-W-r</code></li> <li>Reverse in-order (anti-symmetrische Reihenfolge): <code>r-W-l</code></li> </ul>"},{"location":"2022%20SS/B%C3%A4ume/Traversierung/#breitensuche-breadth-first","title":"Breitensuche (breadth-first)","text":"<ul> <li>Jede Ebene des Baums wird von links nach rechts durchlaufen</li> <li>Algorithmus mittels Queue und wei\u00df/grau/schwarz-Markierung</li> </ul>"},{"location":"2022%20SS/Dynamische%20Speicherverwaltung/Pointer/","title":"Zeiger/Pointer","text":"<p>Alle Pointer haben dieselbe Gr\u00f6\u00dfe.</p>"},{"location":"2022%20SS/Dynamische%20Speicherverwaltung/Pointer/#heap-speicher-in-c","title":"Heap-Speicher in C","text":"<p>Speicher im Heap reservieren: <code>malloc(&lt;size in bytes&gt;)</code></p> <ul> <li>siehe sizeof</li> <li>return: Pointer auf Speicheraddresse</li> </ul> <p>Reservierten Speicher freigeben: <code>free(POINTER)</code></p> <pre><code>// Liegt auf Stack\nint a = 18;\n\n\n\n// Liegt auf Heap\nint *b = &amp;a; // *b == &amp;a == Pointer auf a\n\nint d = *b; // dereferenzieren\n\n// *&amp;a &lt;=&gt; a\n\n// NICHT m\u00f6glich, keine Addresse zugewiesen.\nint *f;\n*f = 7; int alpha(void) {...}\nint *ptr_a(void) = alpha\n\n\nstruct Punkt {\nint x;\nint y;\n}\n\nstruct Punkt* p = malloc(sizeof(struct Punkt));\nif (p == NULL) {\nreturn NULL;\n}\n\np-&gt;x = 1;\np-&gt;y = 2;\n\nfree(p)\n</code></pre>"},{"location":"2022%20SS/Dynamische%20Speicherverwaltung/Speicheraufbau/","title":"Speicheraufbau","text":""},{"location":"2022%20SS/Dynamische%20Speicherverwaltung/Speicheraufbau/#speicherbereiche","title":"Speicherbereiche","text":"<ul> <li>Code<ul> <li>Alle Anweisungen des Programms</li> </ul> </li> <li>Globale Variablen<ul> <li>Von \u00fcberall zugreifbar</li> </ul> </li> <li>Stack - managed memory<ul> <li>Funktionsvariablen</li> <li>R\u00fcckgabewerte</li> <li>R\u00fccksprungsaddressen</li> </ul> </li> <li>Heap - unmanaged memory<ul> <li>Gro\u00dfer Speicherbereich f\u00fcr Daten</li> <li>Daten sind nicht geordnet</li> <li>Gr\u00f6\u00dfe w\u00e4chst, wenn mehr Platz ben\u00f6tigt wird</li> </ul> </li> </ul>"},{"location":"2022%20SS/Dynamische%20Speicherverwaltung/sizeof/","title":"sizeof","text":""},{"location":"2022%20SS/Dynamische%20Speicherverwaltung/sizeof/#sizeoftype","title":"<code>sizeof(&lt;TYPE&gt;)</code>","text":"Type Size int 4 char 1 float 4 double 8 String (= Pointer) 8 void 1"},{"location":"2022%20SS/Graphen/Graph/","title":"Graph","text":"<ul> <li>Graph \\(G = (V, E)\\)<ul> <li>\\(V = \\set{1,2, ..., |V|}\\) - Menge von Knoten</li> <li>\\(E \\subseteq V \\times V\\) - Menge von Pfeilen/Kanten</li> </ul> </li> </ul>"},{"location":"2022%20SS/Graphen/Graph/#gerichtetungerichtet","title":"Gerichtet/Ungerichtet","text":"<ul> <li>Ein gerichteter Graph besteht aus Pfeilen von \\(v\\) nach \\(v'\\).</li> <li>Ein ungerichteter Graph besteht aus Kanten, sodass \\((v,v') \\in E \\implies (v', v) \\in E\\).</li> </ul>"},{"location":"2022%20SS/Graphen/Graph/#darstellung-adjazenzmatrix","title":"Darstellung - Adjazenzmatrix","text":"<ul> <li>Speichert f\u00fcr alle Kanten entweder 0 (<code>false</code>) oder 1 (<code>true</code>) in zweidimensionalem Array</li> <li>Ben\u00f6tigt \\(|V|^2\\) Bits/Booleans</li> <li>Ung\u00fcnstig, wenn die Anzahl an Verbindungen klein ist</li> </ul>"},{"location":"2022%20SS/Graphen/Graph/#darstellung-adjazenzliste","title":"Darstellung - Adjazenzliste","text":"<ul> <li>Gut f\u00fcr das Verfolgen von Pfaden</li> <li>Schlecht f\u00fcr das Hinzuf\u00fcgen oder Entfernen von Knoten</li> <li>Jeder Knoten wird mit einer zus\u00e4tzlichen Liste von Endknoten gespeichert</li> <li>Knoten in Array (statisch) oder in doppelt verketteter Liste (dynamisch)</li> </ul>"},{"location":"2022%20SS/Graphen/Graph/#traversierung","title":"Traversierung","text":"<ul> <li>Algorithmus mittels Stack und Markierung<ul> <li>wei\u00df - neu</li> <li>grau - eingereiht</li> <li>schwarz - besucht</li> </ul> </li> <li>Startknoten \\(v_0\\) auf Stack/Queue</li> <li> <p>Solange Stack/Queue nicht leer:</p> <ul> <li>Einen Knoten entnehmen und schwarz markieren</li> <li>Alle wei\u00dfen Nachbarknoten grau markieren und in Stack/Queue einreihen</li> </ul> </li> <li> <p>Breitensuche - Queue</p> </li> <li>Tiefensuche - Stack</li> </ul>"},{"location":"2022%20SS/Hash%20Tables/Hash%20Table/","title":"Hash Table","text":"<ul> <li>Kombination aus Array und Liste</li> <li>Elemente werden in Array nicht von links nach rechts, sondern durch Hashfunktion zugewiesen</li> </ul>"},{"location":"2022%20SS/Hash%20Tables/Hash%20Table/#einfugen","title":"Einf\u00fcgen","text":"<ul> <li>Hash des Element-Schl\u00fcssels (z.B. Student-Matrikelnummer)</li> </ul>"},{"location":"2022%20SS/Hash%20Tables/Hash%20Table/#suchen","title":"Suchen","text":"<ul> <li>Index = Hash des Element-Schl\u00fcssels</li> <li>Solange mit implementierter Strategie Index erh\u00f6hen, bis der Schl\u00fcsselwert \u00fcbereinstimmt</li> <li>Suchen anhand anderer Attribute (au\u00dfer Schl\u00fcssel) nicht optimiert, stattdessen lineare Suche</li> </ul>"},{"location":"2022%20SS/Hash%20Tables/Hash%20Table/#loschen","title":"L\u00f6schen","text":"<ul> <li>Element auf <code>NULL</code> zu setzen nicht m\u00f6glich, weil eventuell Elemente desselben Hashes eingef\u00fcgt wurden</li> <li>M\u00f6gliche Algorithmen<ol> <li>Platzhalter<ul> <li>Einfach zu realisieren</li> <li>Keine \u00c4nderungen an anderen Funktionen notwendig</li> </ul> </li> <li>Neuberechnung nachfolgender Eintr\u00e4ge<ul> <li>Aufwendig bei gro\u00dfem Cluster</li> <li>Beschleunigt die Suche</li> </ul> </li> </ol> </li> </ul>"},{"location":"2022%20SS/Hash%20Tables/Hash%20Table/#strategien","title":"Strategien","text":"<ul> <li>Kollision - Fall, dass zwei unterschiedliche Eintr\u00e4ge auf denselben Hash/Index eines Arrays zeigen</li> <li>Betrachte Array als Ring (modulo)</li> <li>Erzwungener Abbruch, nachdem alle Felder durchsucht wurden</li> </ul>"},{"location":"2022%20SS/Hash%20Tables/Hash%20Table/#linear-probing","title":"Linear Probing","text":"<ul> <li>\\(h(k, i) = (k + i) \\mod m\\)</li> <li>Index um 1 erh\u00f6hen</li> <li>Problem:<ul> <li>Kollisionsballung verschlechtert Laufzeitverhalten</li> </ul> </li> </ul>"},{"location":"2022%20SS/Hash%20Tables/Hash%20Table/#quadratic-probing","title":"Quadratic Probing","text":"<ul> <li>\\(h(k, i) = (k + c_1 * i + c_2 * i^2) \\mod m\\)</li> <li>Lege \\(c_1\\) und \\(c_2\\) f\u00fcr ein Hash Table konstant an</li> <li>Nimmt immer gr\u00f6\u00dfer werdende Spr\u00fcnge</li> </ul>"},{"location":"2022%20SS/Hash%20Tables/Hash%20Table/#double-hashing","title":"Double Hashing","text":"<ul> <li>\\(h(k, i) = (k + i * h_2(k)) \\mod m\\)</li> <li>H\u00e4ngt von einer unterschiedlichen Hashfunktion \\(h_2(k)\\) ab</li> <li>Sprungweite h\u00e4ngt vom Schl\u00fcssel ab</li> </ul>"},{"location":"2022%20SS/Hash%20Tables/Hash%20Table/#chaining","title":"Chaining","text":"<ul> <li>Jeder Hashwert ist im Array eine verkettete Liste von Eintr\u00e4gen</li> <li>Dynamisch</li> </ul>"},{"location":"2022%20SS/Hash%20Tables/Hashfunktion/","title":"Hashfunktion","text":""},{"location":"2022%20SS/Hash%20Tables/Hashfunktion/#kriterien-fur-gute-hashfunktionen","title":"Kriterien f\u00fcr gute Hashfunktionen","text":"<p>Geringe Wahrscheinlichkeit von Kollisionen</p> <ul> <li>M\u00f6glichst gleichm\u00e4\u00dfige Verteilung der Hashwerte auf erwartete Eingabewerte</li> </ul> <p>Chaos</p> <ul> <li>\u00c4hnliche Eingabewerte sollen zu m\u00f6glichst verschiedenen Hashwerten f\u00fchren</li> <li>Idealfall: \u00c4ndern eines Eingabe-Bits = \u00c4ndern der H\u00e4lfte aller Hash-Bits</li> </ul> <p>Surjektivit\u00e4t</p> <ul> <li>Kein Hashwert soll unm\u00f6glich sein</li> </ul> <p>Effizienz</p> <ul> <li>Funktion muss schnell berechenbar sein</li> <li>Funktion muss ohne gro\u00dfen Speicherverbrauch auskommen</li> </ul> <p>L\u00f6sung: Kryptographische Hashfunktionen (md5, sha1)</p>"},{"location":"2022%20SS/Listen/Liste/","title":"Liste","text":"<ul> <li>Lassen sich zur Laufzeit dimensionieren - H\u00f6here Flexibilit\u00e4t bedeutet verringerte Zugriffsgeschwindigkeit</li> <li>Einf\u00fcgen von Elementen</li> <li>Suchen von Elementen</li> <li>L\u00f6schen von Elementen</li> <li>(\u00c4ndern der Reihenfolge)</li> </ul>"},{"location":"2022%20SS/Listen/Liste/#einfach-verkettete-liste","title":"Einfach verkettete Liste","text":"<ul> <li>\"Horizontales Stapeln\" durch Aneinanderh\u00e4ngen</li> <li>Elemente (bis auf das letzte) verweisen auf Nachfolger</li> <li>Erstes Element (Head) muss gespeichert werden</li> <li>Zeiger auf <code>NULL</code> gilt als Ende der Liste</li> </ul>"},{"location":"2022%20SS/Listen/Liste/#mit-zusatzlichem-ende-der-liste","title":"Mit zus\u00e4tzlichem Ende der Liste","text":"<ul> <li>Erleichtert das Einf\u00fcgen neuer Elemente am Ende der Liste (Tail)</li> </ul>"},{"location":"2022%20SS/Listen/Liste/#doppelt-verkettete-liste","title":"Doppelt verkettete Liste","text":"<ul> <li>Erleichtert das L\u00f6schen von Elementen</li> </ul>"},{"location":"2022%20SS/Listen/Liste/#ring","title":"Ring","text":"<ul> <li>Letztes Element zeigt auf Head</li> </ul>"},{"location":"2022%20SS/Listen/Liste/#stapel-kellerspeicher-stack","title":"Stapel / Kellerspeicher (Stack)","text":"<ul> <li>Erlaubt nur zwei Grundoperationen:<ul> <li>Ablegen (push)</li> <li>Entnehmen des obersten Elements (pop)</li> </ul> </li> <li>Last-in-first-out (LIFO)</li> </ul>"},{"location":"2022%20SS/Listen/Liste/#schlange-queue","title":"Schlange (Queue)","text":"<ul> <li>Erlaubt nur zwei Grundoperationen:<ul> <li>Einf\u00fcgen an den Anfang (enqueue)</li> <li>Entnehmen am Ende (dequeue)</li> </ul> </li> <li>First-in-first-out (FIFO)</li> </ul>"},{"location":"2022%20SS/%C3%9Cbersetzung/Assembler/","title":"Assembler","text":""},{"location":"2022%20SS/%C3%9Cbersetzung/Assembler/#aufbau-von-assembler-kommandos","title":"Aufbau von Assembler-Kommandos","text":"<pre><code>Operator Ziel [Quelle]\n\n- Operator = \"add\", \"mov\", \"inc\"...\n\n- Ziel/Quelle = Konstante, Speicherstelle oder Register\n</code></pre>"},{"location":"2022%20SS/%C3%9Cbersetzung/Assembler/#opcodes","title":"OpCodes","text":"<ul> <li>Operatoren haben Nummern (\"OpCodes\"), z.B. \"add\" = 83.</li> <li>x86 CPUs kennen ca. 200 OpCodes.</li> </ul>"},{"location":"2022%20SS/%C3%9Cbersetzung/Buildprozess/","title":"Buildprozess","text":"<ul> <li>Programme sind in Hochsprachen geschrieben und m\u00fcssen in Maschinensprache \u00fcbersetzt werden.</li> <li>In Hochsprachen k\u00f6nnen Funktionen (und andere Teile des Codes) sowie Funktionsbibliotheken (wieder-)verwendet werden.</li> <li>In Hochsprachen kann umfangreicher Code aus Lesbarkeit in viele Dateien unterteilt werden, die bei \u00dcbersetzung zusammengeb\u00fcndelt werden.</li> </ul> <p>&gt; Code <code>quelltext.c</code> enth\u00e4lt Pr\u00e4pozessor-Anweisungen (z.B. <code>#include</code>, <code>#ifdef</code> usw.)</p> <p>&gt; Pr\u00e4prozessor/Compiler Von C zu Assembler-Code zu Objektdateien (<code>quelltext.o</code>)</p> <p>&gt; Linker Ausf\u00fchrbare Anwendung (<code>quelltext.exe</code>)</p>"},{"location":"2022%20SS/%C3%9Cbersetzung/CPU/","title":"CPU","text":""},{"location":"2022%20SS/%C3%9Cbersetzung/CPU/#vorgang","title":"Vorgang","text":"<ul> <li>Kommando wird aus dem Speicher/Heap in Kommandoregister geladen</li> <li>Kommandologik f\u00fchrt aktuelles Kommando aus<ul> <li>Programmz\u00e4hler manipulieren (z.B. jmp-Befehl)</li> <li>Daten lesen/schreiben (zwischen einem Rechenregister AX, BX, CX, DX und dem Speicher/Heap oder Stackpointer SP)</li> <li>Rechne/Vergleiche (arbeitet auf Rechenregistern)</li> </ul> </li> <li>Programmz\u00e4hler wird um 1 erh\u00f6ht (falls nicht manipuliert)</li> </ul>"},{"location":"2022%20SS/%C3%9Cbersetzung/Maschinensprache/","title":"Maschinensprache","text":"<p>Rechner basieren auf Von-Neumann-Architektur, d.h. CPU f\u00fchrt schrittweise Kommandos (in Maschinensprache) aus.</p> <p>Bus-System transportiert Daten zwischen CPU und Ein-/Ausgabewerk oder Speicherwerk.</p> <p>Speicherwerk h\u00e4lt Daten und Befehlsfolgen vor.</p> <p>Ein-/Ausgabewerk bereitet Daten f\u00fcr Ein-/Ausgabe auf.</p> <p>Merkmale - Hochsprache 1. Kontrollstrukturen 2. Prozedurale Abstraktion 3. Formale Paradigmen     1. objektorientiert     2. funktional/logisch</p> <p>Merkmale - Maschinensprache 1. Simple Vergleichsoperationen 2. Sequentielle Ausf\u00fchrung 3. Sprungbasierte Ablaufsteuerung (goto-statements considered harmful) 4. Keine Kapselung von Daten 5. Prinzip der Zustands\u00e4nderung</p> <p>Unterschiede Hoch- und Maschinensprache &lt; | Hochsprache | Maschinensprache -- | -- | -- Lesbarkeit | x | Einfache Fehlersuche | x |  Realisierbarkeit in Hardware | | x</p>"},{"location":"2022%20WS/01%20Einf%C3%BChrung/Datentypen/","title":"Datentypen","text":""},{"location":"2022%20WS/01%20Einf%C3%BChrung/Datentypen/#java","title":"Java","text":""},{"location":"2022%20WS/01%20Einf%C3%BChrung/Datentypen/#primitive-datentypen","title":"Primitive Datentypen","text":"<ul> <li>Numerisch<ul> <li>Ganzzahlen: <code>byte, short, int, long, char</code></li> <li>Gleitkomma: <code>float, double</code></li> </ul> </li> <li>Andere<ul> <li><code>boolean</code></li> </ul> </li> </ul>"},{"location":"2022%20WS/01%20Einf%C3%BChrung/Datentypen/#referenz-datentypen","title":"Referenz-Datentypen","text":"<ul> <li>Arrays</li> <li>Klassen/Objekte</li> <li>Interfaces</li> <li><code>null</code>-Datentyp</li> </ul>"},{"location":"2022%20WS/01%20Einf%C3%BChrung/Datentypen/#python","title":"Python","text":"<p>Primitive Typen entsprechen immutable types.</p> Typ Immutable bool x int x float x list tuple x str x set frozenset x dict Klassen/Objekte"},{"location":"2022%20WS/02%20Klassen/Abstrakte%20Datentypen%20%28ADT%29/","title":"Abstrakte Datentypen (ADT)","text":"<p>Wenn Attribute nur \u00fcber Methoden ver\u00e4ndert werden k\u00f6nnen, spricht man von \"Abstrakten Datentypen\".</p> <ul> <li>ADT sollten bei objektorientierter Programmierung immer genutzt werden<ul> <li>Aktionen (<code>SETTER</code>) ver\u00e4ndern Objekt-Attribute ohne R\u00fcckgabe</li> <li>Abfragen (<code>GETTER</code>) liefern Aussagen \u00fcber aktuelle Attributwerte</li> </ul> </li> <li>Abstrakte Datentypen kapseln die Attribute nach au\u00dfen hin</li> </ul>"},{"location":"2022%20WS/02%20Klassen/Abstrakte%20Datentypen%20%28ADT%29/#java","title":"Java","text":"<p>In Java realisierbar durch <code>private</code> und <code>protected</code>.</p>"},{"location":"2022%20WS/02%20Klassen/Abstrakte%20Datentypen%20%28ADT%29/#python","title":"Python","text":"<p>Python erlaubt immer direkten Zugriff auf Attribute</p> <ul> <li>strukturell lassen sich ADT nicht erzwingen</li> <li>private Attribute normalerweise mit Unterstrich kennzeichnen (<code>_attribut</code>)</li> <li>siehe Getter und Setter</li> </ul>"},{"location":"2022%20WS/02%20Klassen/Attribute/","title":"Attribute","text":""},{"location":"2022%20WS/02%20Klassen/Attribute/#klassen-attribute","title":"Klassen-Attribute","text":"<ul> <li>auch statische Attribute genannt</li> <li>Java<ul> <li>durch <code>static</code> ver\u00e4nderbar von \u00fcberall, abh\u00e4ngig von der Sichtbarkeit<ul> <li>deshalb popul\u00e4re Fehlerquelle</li> </ul> </li> <li>durch <code>static final</code> wird das Attribut zu einer Konstante.</li> </ul> </li> <li>Python<ul> <li>direkt in Klasse deklariert</li> <li>wird in Instanzen als Objekt-Attributen kopiert</li> </ul> </li> </ul>"},{"location":"2022%20WS/02%20Klassen/Attribute/#objekt-attribute","title":"Objekt-Attribute","text":"<ul> <li>auch Instanz-Attribute genannt</li> </ul> <pre><code>class Dog:\n    kind = \"canine\" # KLASSEN-ATTRIBUT\n\n    def __init__(self, name):\n        self.name = name # OBJEKT-ATTRIBUT\n\nd = Dog(\"Rookie\")\nd.kind # \"canine\" (KOPIERTER Wert)\nd.name # \"Rookie\"\n\nDog.kind # \"canine\" (statisch)\n</code></pre>"},{"location":"2022%20WS/02%20Klassen/Call%20By/","title":"Call By","text":"<p>Argumente eines Methoden-Aufrufs haben verschiedenes Verhalten, abh\u00e4ngig davon, ob es sich um einen primitiven Datentyp oder um eine Referenz handelt. (Datentypen)</p> <p>call by value (primitiver Datentyp / immutable)</p> <ul> <li>Argument wird f\u00fcr die Methode \"kopiert\"</li> <li>ver\u00e4ndert sich deshalb nicht au\u00dferhalb der Methode</li> </ul> <p>call by reference (Referenz / mutable)</p> <ul> <li>Argument wird nicht kopiert</li> <li>Intern wird also die Speicheradresse \u00fcbergeben</li> </ul>"},{"location":"2022%20WS/02%20Klassen/Datenkapselung/","title":"Datenkapselung","text":""},{"location":"2022%20WS/02%20Klassen/Datenkapselung/#implementierungssicht","title":"Implementierungssicht","text":"<ul> <li>Interna des Objekts werden verborgen</li> <li>Konsistenz des Objekts kann garantiert werden</li> </ul>"},{"location":"2022%20WS/02%20Klassen/Datenkapselung/#nutzungssicht","title":"Nutzungssicht","text":"<ul> <li>Nutzer kann nur mit sichtbar gemachte Methoden interagieren</li> <li>Sichtbar gemachte Methoden definieren die Schnittstelle des Objekts</li> </ul>"},{"location":"2022%20WS/02%20Klassen/Datenkapselung/#geheimnisprinzip-der-oop","title":"Geheimnisprinzip der OOP","text":"<ul> <li>\"mache nur sichtbar, was der Nutzer wirklich braucht\"</li> <li>erlaubt ein f\u00fcr den Nutzer transparentes \u00c4ndern der Implementierung</li> </ul> <p>Siehe Sichtbarkeit.</p>"},{"location":"2022%20WS/02%20Klassen/Getter%20und%20Setter/","title":"Getter und Setter","text":""},{"location":"2022%20WS/02%20Klassen/Getter%20und%20Setter/#java","title":"Java","text":"<p>Durch simple Methoden <code>getID()</code>, <code>setID()</code> ohne Besonderheit umgesetzt.</p>"},{"location":"2022%20WS/02%20Klassen/Getter%20und%20Setter/#python","title":"Python","text":"<p>Auf zwei m\u00f6gliche Weisen implementierbar. <pre><code>class MyObject:\n    def __init__(self, id):\n        self._id = id\n\n    def getid(self):\n        return self._id\n\n    def setid(self, value):\n        self._id = value\n\n    def delid(self):\n        del self._id\n\n    id = property(getid, setid, delid, \"Property description.\")\n</code></pre></p> <pre><code>class MyObject:\n    def __init__(self, id):\n        self._id = id\n\n    @property\n    def id(self):\n\"\"\"Property description.\"\"\"\n        return self._id\n\n    @id.setter\n    def id(self, value):\n        self._id = value\n\n    @id.deleter\n    def id(self):\n        del self._id\n</code></pre>"},{"location":"2022%20WS/02%20Klassen/Methodentypen/","title":"Methodentypen","text":""},{"location":"2022%20WS/02%20Klassen/Methodentypen/#java","title":"Java","text":"<p>In Java unterscheidet man zwischen Klassen-Methoden (<code>static</code>) und Objekt/Instanz-Methoden.</p>"},{"location":"2022%20WS/02%20Klassen/Methodentypen/#python","title":"Python","text":"<p>3 Kategorien von Methoden.</p>"},{"location":"2022%20WS/02%20Klassen/Methodentypen/#instanz-methoden","title":"Instanz-Methoden","text":"<ul> <li>erstes Argument: <code>self</code></li> <li>geh\u00f6ren zur konkreten Instanz</li> </ul>"},{"location":"2022%20WS/02%20Klassen/Methodentypen/#klassen-methoden","title":"Klassen-Methoden","text":"<ul> <li>erstes Argument: <code>cls</code></li> <li>Aufruf durch <code>Klasse.methode()</code> oder <code>instanz.methode()</code></li> </ul>"},{"location":"2022%20WS/02%20Klassen/Methodentypen/#statische-methoden","title":"Statische Methoden","text":"<ul> <li>kein implizites Argument</li> <li>direkt in der Klasse definiert</li> <li>Aufruf durch <code>Klasse.methode()</code> oder <code>cls.methode()</code></li> </ul> <pre><code>class Math:\n    @classmethod\n    def version(cls):\n        return \"1.0\"\n\n    @staticmethod\n    def add(a, b):\n        return a + b\n\n    @classmethod\n    def rechne(cls):\n        return cls.add(22, 20)\n</code></pre>"},{"location":"2022%20WS/02%20Klassen/Objekterzeugung%20und%20-L%C3%B6schung/","title":"Objekterzeugung und -L\u00f6schung","text":"<p>Objekte werden aus Klassen (Objekt-Vorlagen) mit dem Aufrufen eines Konstruktors erzeugt. Wenn das Objekt nicht mehr gebraucht wird, muss der belegte Speicher freigegeben werden.</p>"},{"location":"2022%20WS/02%20Klassen/Objekterzeugung%20und%20-L%C3%B6schung/#java","title":"Java","text":"<p>Erzeugen <pre><code>public class MyObject {\nprivate int id;\n\npublic MyObject(int id) {\nthis.id = id;\n}\n}\n\nMyObject mo = new MyObject(123);\n</code></pre></p> <p>L\u00f6schen Automatisch durch Garbage Collector.</p>"},{"location":"2022%20WS/02%20Klassen/Objekterzeugung%20und%20-L%C3%B6schung/#python","title":"Python","text":"<p>Erzeugen <pre><code>class MyObject():\n    def __init__(self, id):\n        self.id = id\n\nmo = MyObject(123)\n</code></pre></p> <p>L\u00f6schen <pre><code>del mo\n</code></pre></p>"},{"location":"2022%20WS/02%20Klassen/Pakete/","title":"Pakete","text":"<p>Pakete erlauben die hierarchische Strukturierung von Code.</p>"},{"location":"2022%20WS/02%20Klassen/Pakete/#java","title":"Java","text":"<ul> <li>Klassen mit demselben Namen k\u00f6nnen in mehreren Packages definiert sein.</li> <li>Pakete entsprechen normalerweise auch individuellen Ordnern im Projektverzeichnis.</li> <li><code>java.lang</code> ist das \"Default-Paket\" und muss nicht extra importiert werden.</li> </ul> <pre><code>// Package aller Klassen, die in dieser Datei definiert werden\npackage mypackage;\n\n// Erm\u00f6glicht das Nutzen aller Klassen aus dem java.util Package\nimport java.util.*;\n\n// Erm\u00f6glicht das Nutzen der Klasse OtherClass aus dem Package otherpackage\nimport otherpackage.OtherClass;\n</code></pre> <pre><code>// Nutzt die Klasse OtherClass ohne Import\notherpackage.OtherClass instanz = new otherPackage.OtherClass();\n</code></pre>"},{"location":"2022%20WS/02%20Klassen/Pakete/#python","title":"Python","text":"<p>Python unterscheidet zwischen Modulen und Paketen.</p>"},{"location":"2022%20WS/02%20Klassen/Pakete/#modul","title":"Modul","text":"<ul> <li>entspricht einer einzelnen Python-Datei (<code>my_module.py</code>)</li> <li>importieren mit <code>import my_module</code></li> </ul>"},{"location":"2022%20WS/02%20Klassen/Pakete/#paket","title":"Paket","text":"<ul> <li>entspricht einem Ordner</li> <li>Ordner muss eine Datei namens <code>__init__.py</code> beinhalten</li> </ul>"},{"location":"2022%20WS/02%20Klassen/Sichtbarkeit/","title":"Sichtbarkeit","text":"<p>Alle Klassen, Methoden und Variablen in Java haben eine \"Sichtbarkeit\".</p> UML-Symbol Sichtbarkeit Selbes Package Unterklassen Au\u00dferhalb des Package <code>-</code> <code>private</code> <code>~</code> <code>default (\"package-private\")</code> x <code>#</code> <code>protected</code> x x <code>+</code> <code>public</code> x x x"},{"location":"2022%20WS/02%20Klassen/Sichtbarkeit/#sichtbarkeit-von-klassen","title":"Sichtbarkeit von Klassen","text":"<ul> <li>mehrere Klassendefinitionen pro Datei m\u00f6glich</li> <li>genau eine Klasse muss <code>public</code> sein und dem Dateinamen gleichen</li> <li>Klassen ohne <code>public</code> sind nur innerhalb des Datei-Packages nutzbar</li> </ul> <pre><code>package mypackage;\n\npublic class Klasse1 { // public\n...\n}\n\nclass Klasse2 { // package-private\n...\n}\n</code></pre>"},{"location":"2022%20WS/02%20Klassen/%C3%9Cberladen/","title":"\u00dcberladen","text":""},{"location":"2022%20WS/02%20Klassen/%C3%9Cberladen/#java","title":"Java","text":"<p>Es k\u00f6nnen mehrere Methoden mit dem gleichen Namen aber unterschiedlicher Signatur deklariert werden. <pre><code>public int max(int a, int b) {\nreturn a &lt; b ? b : a;\n}\n\npublic double max(double a, double b) {\nreturn a &lt; b ? b : a;\n}\n</code></pre></p> <p>(auch mit Konstruktoren m\u00f6glich)</p>"},{"location":"2022%20WS/02%20Klassen/%C3%9Cberladen/#python","title":"Python","text":"<p>Nicht m\u00f6glich, weil Methoden wie Attribute behandelt werden. Weitere Deklarationen desselben Namens \u00fcberschreiben die vorherige Definition.</p> <p>Stattdessen k\u00f6nnen Default-Werte f\u00fcr Argumente definiert werden.</p> <pre><code>def refresh_page(delete_cache = False):\n    # Implementierung...\n\nrefresh_page() # delete_cache = False\n\nrefresh_page(True) # delete_cache = True\n\nrefresh_page(delete_cache=True) # expliziter Parameter\n</code></pre>"},{"location":"2022%20WS/03%20Vererbung%20und%20Polymorphie/Abstrakte%20Klassen/","title":"Abstrakte Klassen","text":"<ul> <li>Klassen, von denen keine konkreten Objekte/Instanzen erzeugt werden k\u00f6nnen</li> <li>werden als Schnittstellen verwendet (mit teilweiser Standardimplementierung)</li> <li>k\u00f6nnen abstrakte Methoden(-Signaturen) beinhalten, welche erst in Unterklassen einen K\u00f6rper bekommen</li> <li>falls die Unterklasse einer abstrakten Oberklasse auch als <code>abstract</code> markiert ist, m\u00fcssen die abstrakten Methoden der Oberklasse nicht implementiert werden</li> </ul> <pre><code>abstract class Shape {\nprivate int color;\n\npublic Shape(int color) {\nthis.color = color;\n}\n\npublic abstract double getArea();\n}\n\nclass Circle extends Shape {\nprivate double radius;\n\npublic Circle(int color, double radius) {\nsuper(color);\nthis.radius = radius;\n}\n\n@Override\npublic double getArea() { // MUSS \u00fcberschrieben werden, weil zuvor abstract\n// area = \u03c0r\u00b2\nreturn Math.PI * radius * radius;\n}\n}\n</code></pre>"},{"location":"2022%20WS/03%20Vererbung%20und%20Polymorphie/Interfaces/","title":"Interfaces","text":"<p>Interfaces = Schnittstellen</p> <p>Interfaces k\u00f6nnen von anderen Interfaces erben (<code>extends</code>).</p>"},{"location":"2022%20WS/03%20Vererbung%20und%20Polymorphie/Interfaces/#implementierungs-beziehung","title":"Implementierungs-Beziehung","text":"<ul> <li>Attribute innerhalb eines <code>interface</code> sind implizit <code>static final</code> (also konstant)</li> <li>leere Interfaces hei\u00dfen \"Marker\"-Schnittstellen</li> </ul>"},{"location":"2022%20WS/03%20Vererbung%20und%20Polymorphie/Interfaces/#java-8","title":"Java 8+","text":"<ul> <li>m\u00f6gliche Mehrfachvererbung durch <code>default</code> Methoden</li> <li>Definition von \"Utilities\" durch <code>static</code> Methoden</li> </ul>"},{"location":"2022%20WS/03%20Vererbung%20und%20Polymorphie/Interfaces/#vergleich-zu-abstrakten-klassen","title":"Vergleich zu abstrakten Klassen","text":"Interface Abstrakte Klasse instanziierbar Erb-Notation <code>class Klasse implements Interface1, Interface2 {}</code> <code>class Klasse extends OberKlasse {}</code> mehrfach verwendbar x"},{"location":"2022%20WS/03%20Vererbung%20und%20Polymorphie/Mehrfachvererbung/","title":"Mehrfachvererbung","text":"<p>Eine Klasse kann (prinzipiell) von mehreren Basisklassen erben (\"Mehrfachvererbung\"). In Java ist der \u00dcbersicht halber nur Einfachvererbung m\u00f6glich.</p>"},{"location":"2022%20WS/03%20Vererbung%20und%20Polymorphie/Mehrfachvererbung/#interfaces-mit-default-methoden","title":"Interfaces mit Default-Methoden","text":"<p>Java 8+ erlaubt default-Methoden innerhalb von Interfaces, welche eine Standard-Implementierung vorgeben.</p> <pre><code>interface MyInterface {\nvoid firstMethod();\nvoid secondMethod();\n\ndefault void callAllMethods() {\nfirstMethod();\nsecondMethod();\n}\n}\n</code></pre> <p>Damit ist Mehrfachvererbung auch in Java m\u00f6glich.</p> <pre><code>interface Printer {\ndefault void printName() {\nSystem.out.println(\"Unknown\");\n}\n}\n\ninterface InputReceiver {\ndefault void handleInput(char keyPressed) {\nSystem.out.println(\"Pressed key \" + keyPressed);\n}\n}\n\nclass Game implements Printer, InputReceiver {}\n\nGame game = new Game();\ngame.printName(); // \"Unknown\"\ngame.handleInput('a'); // \"Pressed key a\"\n</code></pre>"},{"location":"2022%20WS/03%20Vererbung%20und%20Polymorphie/Mehrfachvererbung/#doppelte-methoden","title":"Doppelte Methoden","text":"<p>Fehler, falls zwei implementierte Interfaces eine Methode mit gleichem Namen und gleichen Argumenten definieren.</p> <pre><code>interface Bob1 {\ndefault void bob() {\nSystem.out.println(\"Bob1::bob\");\n}\n}\n\ninterface Bob2 {\ndefault void bob() {\nSystem.out.println(\"Bob2::bob\");\n}\n}\n\nclass Bob implements Bob1, Bob2 {}\n</code></pre> <p>Kann behoben werden durch Disambiguation.</p> <pre><code>class Bob implements Bob1, Bob2 {\n@Override\npublic void bob() {\nBob2.super.bob();\n}\n}\n</code></pre>"},{"location":"2022%20WS/03%20Vererbung%20und%20Polymorphie/Polymorphie/","title":"Polymorphie","text":"<p>Polymorphie = Vielgestaltigkeit</p>"},{"location":"2022%20WS/03%20Vererbung%20und%20Polymorphie/Polymorphie/#statische-bindung","title":"Statische Bindung","text":"<ul> <li>Attribute werden nicht \u00fcberschrieben (es kann mehrere Attribute mit demselben Namen geben)</li> <li>private Methoden k\u00f6nnen nicht \u00fcberschrieben werden (sind automatisch <code>final</code>)</li> <li>statische Methoden \u00fcberschreiben sich nicht (Teil der Klasse statt der instanziierten Objekte)</li> </ul>"},{"location":"2022%20WS/03%20Vererbung%20und%20Polymorphie/UML/","title":"UML","text":"<p>UML-Diagramme sind Projektentw\u00fcrfe.</p> <ul> <li>Klassen<ul> <li>Attribute</li> <li>Methoden</li> </ul> </li> <li>Klassenbeziehungen<ul> <li>Datentypen der Attribute</li> <li>Signaturen der Methoden</li> </ul> </li> </ul> Duck <code>- name : string</code> <code>- color : int</code> <code>+ Duck(string, int)</code> <code>+ getName() : string</code> <code>~ getColor() : int</code>"},{"location":"2022%20WS/03%20Vererbung%20und%20Polymorphie/UML/#klassendiagramm","title":"Klassendiagramm","text":"<ul> <li>Klassenname: zentriert und in Fettschrift<ul> <li>\u00dcberschrift ggf. <code>&lt;&lt;interface&gt;&gt;</code>, <code>&lt;&lt;abstract&gt;&gt;</code> oder <code>&lt;&lt;enumeration&gt;&gt;</code></li> </ul> </li> <li>Liste von Attributen <code>&lt;-|~|#|+&gt; &lt;name&gt;: &lt;type&gt;</code><ul> <li>Sichtbarkeit</li> <li>Name</li> <li>Typ</li> </ul> </li> <li>Liste von Methoden/Operationen <code>&lt;-|~|#|+&gt; &lt;name&gt;(&lt;param-type ...&gt;): &lt;return-type&gt;</code><ul> <li>Sichtbarkeit</li> <li>Name</li> <li>Argumententypen</li> <li>R\u00fcckgabetyp</li> </ul> </li> </ul>"},{"location":"2022%20WS/03%20Vererbung%20und%20Polymorphie/UML/#besonderheiten","title":"Besonderheiten","text":"<ul> <li>abstrakte Klassen und Methoden kursiv oder <code>&lt;abstract&gt;</code></li> <li>statische Attribute und Methoden unterstrichen oder <code>&lt;static&gt;</code></li> </ul>"},{"location":"2022%20WS/03%20Vererbung%20und%20Polymorphie/UML/#generalisierung","title":"Generalisierung","text":"<ul> <li>Pfeil von Unterklasse auf Oberklasse</li> <li><code>extends</code> = durchgezogen</li> <li><code>implements</code> = gestrichelt</li> </ul>"},{"location":"2022%20WS/03%20Vererbung%20und%20Polymorphie/Upcast%20und%20Downcast/","title":"Upcast und Downcast","text":"<p>Nur in Java relevant, weil es eine streng typisierte Sprache ist.</p>"},{"location":"2022%20WS/03%20Vererbung%20und%20Polymorphie/Upcast%20und%20Downcast/#upcast-verallgemeinern","title":"Upcast (Verallgemeinern)","text":"<p>Instanz einer Unterklasse wird als eine ihrer Oberklassen behandelt.</p> <ul> <li>immer erlaubt</li> <li>nur Methoden und Attribute der Superklasse verwendbar</li> <li>beim Aufrufen einer Methode wird dennoch die \"unterste\" \u00fcberschriebene Variante aufgerufen (dynamisches Binding / late binding)</li> </ul>"},{"location":"2022%20WS/03%20Vererbung%20und%20Polymorphie/Upcast%20und%20Downcast/#downcast-spezifizieren","title":"Downcast (Spezifizieren)","text":"<p>Instanz einer Oberklasse wird als eine ihrer Unterklassen behandelt.</p> <ul> <li>Casting Exception, falls die Instanz nicht der gecasteten Unterklasse entspricht</li> <li>erlaubt das Nutzen von erg\u00e4nzten Methoden und Attributen</li> </ul> <pre><code>// Upcast\nShape shape = new Circle(...);\n\n// Downcast\nCircle circle = (Circle) shape;\n</code></pre>"},{"location":"2022%20WS/03%20Vererbung%20und%20Polymorphie/Vererbung/","title":"Vererbung","text":"<p>Klassen k\u00f6nnen von anderen Klassen \"abgeleitet\" werden.</p> <p>Abgeleitete Klassen</p> <ul> <li>erben alle Attribute und Methoden der Basisklasse</li> <li>k\u00f6nnen Attribute und Methoden erg\u00e4nzen</li> <li>k\u00f6nnen Methoden modifizieren/\u00fcberschreiben</li> </ul> <p>Prinzipiell erlauben Programmiersprachen Mehrfachvererbung.</p>"},{"location":"2022%20WS/03%20Vererbung%20und%20Polymorphie/Vererbung/#nomenklatur","title":"Nomenklatur","text":"<ul> <li>Vererbung = Erweiterung = Ableitung</li> <li>Basisklasse = Oberklasse = Elternklasse = Superklasse \\(\\Rightarrow\\) Verallgemeinerung</li> <li>abgeleitete Klasse = Unterklasse = Kindklasse = Subklasse \\(\\Rightarrow\\) Spezialisierung</li> </ul> <pre><code>class Shape {\nprivate int color;\n\npublic Shape(int color) {\nthis.color = color;\n}\n}\n\nclass Circle extends Shape {\nprivate double radius;\n\npublic Circle(int color, double radius) {\nsuper(color);\nthis.radius = radius;\n}\n}\n</code></pre> <pre><code>class Shape:\n    def __init__(self, color):\n        self.color = color\n\nclass Circle(Shape):\n    def __init__(self, color, radius):\n        super(Circle, self).__init__(color)\n        self.radius = radius\n</code></pre>"},{"location":"2022%20WS/03%20Vererbung%20und%20Polymorphie/%C3%9Cberschreiben/","title":"\u00dcberschreiben","text":"<p>Eine Subklasse kann geerbte Methoden der Superklasse \u00fcberschreiben (override), d.h. neu implementieren.</p>"},{"location":"2022%20WS/03%20Vererbung%20und%20Polymorphie/%C3%9Cberschreiben/#java","title":"Java","text":"<p>Methode muss die gleiche Signatur wie in der Superklasse haben und mit <code>@Override</code> gekennzeichnet werden.</p> <p>Konstruktoren</p> <ul> <li>Der Konstruktor einer Unterklasse f\u00fchrt immer zuerst einen Konstruktor der Oberklasse aus.</li> <li>Erste Zeile des Sub-Konstruktors: <code>super( Argumente... )</code></li> </ul> <pre><code>class SuperClass {\nprivate int id;\n\npublic SuperClass(int id) {\nthis.id = id;\n}\n\npublic void print(String msg) {\nSystem.out.println(msg);\n}\n}\n\nclass SubClass extends SuperClass {\nprivate String prefix;\n\npublic SubClass(String prefix, int id) {\nsuper(id);\nthis.prefix = prefix;\n}\n\n@Override\npublic void print(String msg) {\nsuper.print(prefix + msg);\n}\n}\n\n// darf vom Typ SuperClass oder SubClass sein\nSuperClass instanz = new SubClass(\"Printing: \", 0);\ninstanz.id; // 0\ninstanz.print(\"Hallo\"); // \"Printing: Hallo\"\n</code></pre>"},{"location":"2022%20WS/04%20Collections/Collection/","title":"Collection","text":"<p>Collection Interface besitzt Funktionen:</p> <ul> <li>einf\u00fcgen eines Elements</li> <li>l\u00f6schen eines Elements</li> <li>l\u00f6schen aller Elemente</li> <li>abfragen, ob <code>x</code> Teil der Collection ist</li> <li>abfragen, ob leer</li> <li>durchlaufen aller Elemente</li> </ul> <pre><code>interface Collection&lt;E&gt; {\nboolean add(E o);\nboolean remove(Object o);\nvoid clear();\nint size();\nboolean isEmpty();\nObject[] toArray();\nIterator&lt;E&gt; iterator();\n}\n</code></pre> <p>Siehe Iterator. Implementiert durch List und Set.</p>"},{"location":"2022%20WS/04%20Collections/Collection/#vergleich-von-listen-und-mengen-laufzeitkomplexitat","title":"Vergleich von Listen und Mengen (Laufzeitkomplexit\u00e4t)","text":"Klasse add() remove() get() contains() Durchlauf-Reihenfolge <code>ArrayList</code> O(1) O(n) O(1) O(n) Einf\u00fcgung <code>LinkedList</code> ^ (schnell) ^ O(n) ^ Einf\u00fcgung <code>TreeSet</code> O(log n) O(log n) O(log n) Ordnung <code>HashSet</code> O(1) O(1) O(1) unspezifisch"},{"location":"2022%20WS/04%20Collections/Comparable/","title":"Comparable","text":"<p>Schnittstelle, um Objekte vergleichbar zu machen.</p> <ul> <li><code>&lt; 0</code>, falls <code>a &lt; b</code></li> <li><code>== 0</code>, falls <code>a == b</code></li> <li><code>&gt; 0</code>, falls <code>a &gt; b</code></li> </ul> <pre><code>interface Comparable&lt;T&gt; {\nint compareTo(T other);\n}\n\nclass Integer implements Comparable&lt;Integer&gt; {\npublic int compareTo(Integer other) {\nreturn 3 - 7; &lt; 0\n}\n}\n</code></pre>"},{"location":"2022%20WS/04%20Collections/Comparable/#comparator","title":"Comparator","text":"<p>Typ-Generische Schnittstelle, die zwei Objekte desselben Typs</p> <pre><code>interface Comparator&lt;T&gt; {\nint compare(T a, T b);\n}\n</code></pre>"},{"location":"2022%20WS/04%20Collections/Container/","title":"Container","text":"<p>Container definieren eine Speicherung und Verwaltung von Objekten.</p> <ul> <li>Array: einfachste Container-Datenstruktur</li> <li>Java enth\u00e4lt vordefinierte Container-Klassen und -Schnittstellen</li> </ul> <p>Es gibt 2 Arten von Containern:</p> <ul> <li>Collection: reine Sammlung von Objekten</li> <li>Map: Abbildung zwishcen Objekten (z.B. Telefonverzeichnis)</li> </ul>"},{"location":"2022%20WS/04%20Collections/Container/#container-schnittstellen","title":"Container-Schnittstellen","text":"<ul> <li>Collection<ul> <li>Set<ul> <li>SortedSet</li> </ul> </li> <li>List</li> </ul> </li> <li>Map<ul> <li>SortedMap</li> </ul> </li> </ul>"},{"location":"2022%20WS/04%20Collections/Enum/","title":"Enum","text":"<ul> <li>Alternative zu <code>class</code></li> <li>ohne Vererbung</li> <li>f\u00fcr wenige konstante Instanzen</li> </ul> <p>Instanzmethoden:</p> <ul> <li><code>ordinal()</code>: Index der Definition</li> <li><code>compareTo()</code>: Index vergleichen</li> </ul> <p>Klassenmethoden:</p> <ul> <li><code>values()</code>: Iterable aller definierter Konstanten im Enum</li> </ul>"},{"location":"2022%20WS/04%20Collections/Enum/#uml-notation","title":"UML-Notation","text":"<code>&lt;&lt;enumeration&gt;&gt;</code> Weekday <code>+ MONDAY</code> <code>+ TUESDAY</code> <code>+ WEDNESDAY</code> <code>+ THURSDAY</code> <code>+ FRIDAY</code> <code>+ SATURDAY</code> <code>+ SUNDAY</code>"},{"location":"2022%20WS/04%20Collections/Enum/#switch-vergleich","title":"<code>switch</code>-Vergleich","text":"<pre><code>Weekday day = Weekday.SATURDAY;\nswitch (day) {\ncase MONDAY:\ncase TUESDAY:\ncase WEDNESDAY:\ncase THURSDAY:\ncase FRIDAY:\nSystem.out.println(\"Wochentag\");\nbreak;\ncase SATURDAY:\ncase SUNDAY:\nSystem.out.println(\"Wochenende\");\nbreak;\n}\n</code></pre>"},{"location":"2022%20WS/04%20Collections/Generics/","title":"Generics","text":"<p>Siehe Typisierung.</p>"},{"location":"2022%20WS/04%20Collections/Generics/#generische-datentypen","title":"Generische Datentypen","text":"<p>Man will</p> <ul> <li>beliebige Elementtypen zulassen</li> <li>beim Aufrufen von Container-Operationen einen konkreten Typ nutzen</li> </ul>"},{"location":"2022%20WS/04%20Collections/Generics/#losung-1-polymorphe-behalter","title":"L\u00f6sung 1 - Polymorphe Beh\u00e4lter","text":"<ul> <li>alle Elemente als <code>Object</code> behandelt</li> <li>manuelles Downcasting</li> <li>keine Typsicherheit</li> </ul>"},{"location":"2022%20WS/04%20Collections/Generics/#losung-2-generische-datentypen","title":"L\u00f6sung 2 - Generische Datentypen","text":"<ul> <li>Deklaration einer Collection erh\u00e4lt Elementtyp als generischen Typ-Parameter</li> <li>seit Java 5</li> <li><code>List&lt;E&gt;</code> = generischer Typ, <code>E</code> = Typ-Parameter</li> </ul> <pre><code>interface List&lt;E&gt; {\nvoid add(int index, E element);\n}\n\nclass ArrayList&lt;E&gt; extends List&lt;E&gt; {\npublic void add(int index, E element) { ... }\n}\n\n// Liste von Strings erzeugen\nArrayList&lt;String&gt; myList = new ArrayList&lt;String&gt;();\n\n// seit Java 7 k\u00fcrzer durch Typ-Inferenz\nArrayList&lt;String&gt; myList = new ArrayList&lt;&gt;();\n</code></pre>"},{"location":"2022%20WS/04%20Collections/Iterator/","title":"Iterator","text":"<p>Ein Iterator bewegt sich \u00fcber eine Sequenz, ohne die unterliegende Datenstruktur zu kennen.</p> <ul> <li>leicht herzustellen</li> <li>bewegen sich in nur eine Richtung</li> </ul> <pre><code>interface Iterator&lt;E&gt; {\nboolean hasNext();\nE next();\nvoid remove();\n}\n</code></pre>"},{"location":"2022%20WS/04%20Collections/Iterator/#iterable","title":"Iterable","text":"<p><code>for-each</code>-Schleifen sind eine einfachere Schreibweise, die <code>iterator()</code>-Methode von <code>Iterable</code>-Objekten (alle Collections sind <code>Iterable</code>) zu nutzen.</p> <pre><code>void cancelAll(Collection&lt;TimerTask&gt; c) {\nfor (TimerTask t : c) {\nt.cancel(); // Aktion auf einzelnem Element\n}\n}\n</code></pre> <pre><code>void cancelAll(Collection&lt;TimerTask&gt; c) {\nfor (Iterator&lt;TimerTask&gt; i = c.iterator(); i.hasNext();) {\nTimerTask t = i.next();\nt.cancel(); // Aktion auf einzelnem Element\n}\n}\n</code></pre>"},{"location":"2022%20WS/04%20Collections/List/","title":"List","text":"<pre><code>interface List&lt;E&gt; extends Collection&lt;E&gt; {\nvoid add(int index, E o);\nboolean addAll(int index, Collection&lt;E&gt; c);\nE get(int index);\nint indexOf(Object o);\nint lastIndexOf(Object o);\nE remove(int index);\nE set(int index, E o);\n}\n</code></pre>"},{"location":"2022%20WS/04%20Collections/List/#arraylist","title":"ArrayList","text":"<ul> <li>realisiert durch internen Array, wessen Gr\u00f6\u00dfe bei <code>add()</code> und <code>remove()</code> automatisch angepasst wird</li> <li>falls Platz f\u00fcr neue Elemente ben\u00f6tigt ist, Array um ca. 50% vergr\u00f6\u00dfern</li> <li>Initiale Gr\u00f6\u00dfe <code>10</code> Elemente (falls nicht im Konstruktor anders angegeben)</li> </ul>"},{"location":"2022%20WS/04%20Collections/List/#linkedlist","title":"LinkedList","text":"<ul> <li>realisiert durch (doppelt) verkettete Liste</li> <li>kann als Stack und als Queue gleichzeitig verwendet werden</li> <li>zus\u00e4tzliche Operationen <code>addFirst(), getFirst(), removeFirst()</code> und <code>addLast(), getLast(), removeLast()</code></li> </ul>"},{"location":"2022%20WS/04%20Collections/Map/","title":"Map","text":"<p>Map = Dictionary = Abbildung</p> <ul> <li>Gruppe von Schl\u00fcssel-Werte-Objektpaaren</li> <li>realisiert assoziativen Speicher (Zugriff \u00fcber individuelle Schl\u00fcssel statt Index)</li> </ul>"},{"location":"2022%20WS/04%20Collections/Map/#eigenschaften","title":"Eigenschaften","text":"<ul> <li>jeder Schl\u00fcssel hat entweder gar keinen oder genau einen Wert</li> <li>falls der Schl\u00fcssel beim Einf\u00fcgen schon vorhanden ist, wird der Wert \u00fcberschrieben</li> <li>l\u00f6schen eines Schl\u00fcssels l\u00f6scht das ganze Paar</li> <li>Sortierung beliebig</li> </ul> <pre><code>interface Map&lt;K, V&gt; {\nvoid clear();\nint size();\nboolean isEmpty();\nV put(K key, V value);\nV get(Object key);\nV remove(Object key);\nboolean containsKey(Object key);\nboolean containsValue(Object value);\n}\n</code></pre>"},{"location":"2022%20WS/04%20Collections/Map/#treemap","title":"TreeMap","text":"<ul> <li>Schl\u00fcsselmenge in bin\u00e4rem Suchbaum</li> <li>funktioniert mit Comparable</li> </ul>"},{"location":"2022%20WS/04%20Collections/Map/#hashmap","title":"HashMap","text":"<ul> <li>Schl\u00fcsselmenge durch Hashing</li> </ul>"},{"location":"2022%20WS/04%20Collections/Set/","title":"Set","text":"<p>Sets/Mengen beinhalten keine doppelten Elemente.</p>"},{"location":"2022%20WS/04%20Collections/Set/#hashset","title":"HashSet","text":"<p>Implementiert Element-Eindeutigkeit mithilfe Hashings.</p> <ul> <li>Vorteil: schnelles Einf\u00fcgen, L\u00f6schen und Suchen</li> <li>Nachteil: Speicherverbrauch</li> </ul>"},{"location":"2022%20WS/04%20Collections/Set/#sortedset","title":"SortedSet","text":"<p>Sortieren mithilfe von Comparable-Schnittstelle.</p> <ul> <li>Elemente sind Comparable</li> <li>oder expliziten Comparator im Konstruktor \u00fcbergeben</li> </ul>"},{"location":"2022%20WS/04%20Collections/Set/#treeset","title":"TreeSet","text":"<p>Sortierung mithilfe eines balancierten bin\u00e4ren Suchbaums.</p>"},{"location":"2022%20WS/04%20Collections/Typisierung/","title":"Typisierung","text":""},{"location":"2022%20WS/04%20Collections/Typisierung/#typsicherheit","title":"Typsicherheit","text":"<p>Werden Typfehler sp\u00e4testens zur Laufzeit erkannt, spricht man von typsicheren Sprachen.</p> <ul> <li>keine Typverletzungen</li> <li>Typsicherheit zugestellt durch Compiler bzw. Interpreter</li> </ul>"},{"location":"2022%20WS/04%20Collections/Typisierung/#typprufung","title":"Typpr\u00fcfung","text":"<ul> <li>Verwendung von Datentypen innerhalb des Typsystems pr\u00fcfen</li> <li>Zuweisungen m\u00fcssen nicht dem exakten Typ entsprechen (z.B. <code>float zahl = 4;</code>)</li> <li>statisch typisiert: Typpr\u00fcfung w\u00e4hrend Kompilierung</li> <li>dynamisch typisiert: Typpr\u00fcfung prim\u00e4r zur Laufzeit</li> </ul>"},{"location":"2022%20WS/04%20Collections/Typisierung/#sprachen","title":"Sprachen","text":""},{"location":"2022%20WS/04%20Collections/Typisierung/#java","title":"Java","text":"<ul> <li>statisch: Typsicherheit von primitiven Datentypen bereits vom Bytecode-Compiler <code>javac</code> gepr\u00fcft</li> <li>dynamisch: l\u00e4sst dynamische Typpr\u00fcfungen durch <code>instanceof</code>-Operator zu</li> </ul>"},{"location":"2022%20WS/04%20Collections/Typisierung/#python-javascript-php-ruby","title":"Python, JavaScript, PHP, Ruby","text":"<ul> <li>vollst\u00e4ndig dynamisch typisiert</li> </ul>"},{"location":"2022%20WS/06%20Innere%20Klassen/Assoziation/","title":"Assoziation","text":""},{"location":"2022%20WS/06%20Innere%20Klassen/Assoziation/#beziehungen-zwischen-uml-klassen","title":"Beziehungen zwischen UML-Klassen","text":"<ul> <li>ungerichtet (kein Pfeil): \"nicht definiert\"</li> <li>gerichtet (1-2 Pfeilenden)</li> <li>reflexiv (auf sich selbst gerichtet)</li> </ul>"},{"location":"2022%20WS/06%20Innere%20Klassen/Assoziation/#spezielle-typen-von-assoziation","title":"Spezielle Typen von Assoziation","text":""},{"location":"2022%20WS/06%20Innere%20Klassen/Assoziation/#aggregation","title":"Aggregation","text":"<pre><code>public class Foo {\nprivate Bar bar;\nFoo(Bar bar) {\nthis.bar = bar;\n}\n}\n</code></pre>"},{"location":"2022%20WS/06%20Innere%20Klassen/Assoziation/#komposition","title":"Komposition","text":"<ul> <li>starke Form der Aggregation</li> <li>Teil-Objekt kann nicht ohne sein Komposit-Objekt existieren<ul> <li>darf also nicht nach au\u00dfen weitergegeben werden</li> </ul> </li> </ul> <pre><code>public class Foo {\nprivate Bar bar = new Bar();\nprivate class Bar{\n...\n}\n}\n</code></pre> <pre><code>public class Foo {\nprivate Bar bar;\npublic Foo() {\nbar = new Bar(this);\n}\n}\n\nclass Bar {\nprivate Foo foo;\npublic Bar(Foo foo) {\nthis.foo = foo;\n}\n}\n</code></pre>"},{"location":"2022%20WS/06%20Innere%20Klassen/Innere%20Klassen/","title":"Innere Klassen","text":""},{"location":"2022%20WS/06%20Innere%20Klassen/Innere%20Klassen/#vorteile-von-inneren-klassen","title":"Vorteile von inneren Klassen","text":"<ul> <li>logische Gruppierung vereinfacht die Pakete</li> <li>erh\u00f6hte Verkapselung (kann private Felder der \u00e4u\u00dferen Klasse nutzen und ver\u00e4ndern)</li> <li>Code besser lesbar und wartbar (good practice)</li> </ul>"},{"location":"2022%20WS/06%20Innere%20Klassen/Innere%20Klassen/#statische-klassen","title":"Statische Klassen","text":"<ul> <li>K\u00f6nnen von \u00fcberall verwendet werden mithilfe von <code>A.B</code></li> </ul> <pre><code>public class Account {\nprivate int userId;\nprivate Permissions perm;\n\npublic Account(int userId) {\nthis.userId = userId;\nperm = new Permissions();\n}\n\npublic static class Permissions {\npublic boolean canRead;\npublic boolean canWrite;\npublic boolean canDelete; }\n\npublic Permissions getPermissions() { return perm; }\n}\n</code></pre> <pre><code>Account.Permissions = new Account.Permissions();\n</code></pre>"},{"location":"2022%20WS/06%20Innere%20Klassen/Innere%20Klassen/#instanzklassen","title":"Instanzklassen","text":"<ul> <li>K\u00f6nnen auf alle Eigenschaften einer Instanz zugreifen</li> </ul> <pre><code>public interface Selector&lt;T&gt; {\nIterable&lt;T&gt; getItems();\n}\n\npublic class Sequence&lt;T&gt; {\nprivate List&lt;T&gt; items;\n\nprivate class SequenceSelector implements Selector {\n@Override\npublic Iterable&lt;T&gt; getItems() {\nreturn items; // Private member of Sequence\n}\n}\n\npublic Selector selector() {\nreturn new SequenceSelector();\n}\n}\n</code></pre>"},{"location":"2022%20WS/06%20Innere%20Klassen/Innere%20Klassen/#lokale-klassen","title":"Lokale Klassen","text":"<pre><code>class Math {\npublic static void calculate() {\n// Lokale innere klasse\nclass Differntial {\n...\n}\n\nvar diff = new Differential();\n}\n\n}\n</code></pre>"},{"location":"2022%20WS/06%20Innere%20Klassen/Innere%20Klassen/#anonyme-klassen","title":"Anonyme Klassen","text":"<pre><code>interface Callback {\nvoid call();\n}\n\nclass Delay {\npublic final Callback callback;\n\npublic Delay(Callback callback) {\nthis.callback = callback;\n}\n}\n\npublic static void main(String[] args) {\nvar delay = new Delay(new Callback() {\n@Override\nvoid call() {\nSystem.out.println(\"Done\");\n}\n});\n}\n</code></pre>"},{"location":"2022%20WS/06%20Innere%20Klassen/Innere%20Klassen/#python","title":"Python","text":"<pre><code>class Outer():\n    class Inner():\n        def __init__(self, name):\n            self.name = name\n\n    def __init__(self):\n        self.construct = Outer.Inner(\"Construct\")\n\n    def __str__(self):\n        return f\"Outer '{self.construct.name}'\"\n</code></pre>"},{"location":"2022%20WS/06%20Innere%20Klassen/Lambda/","title":"Lambda","text":"<p>Lambda = Anonyme Funktion</p>"},{"location":"2022%20WS/06%20Innere%20Klassen/Lambda/#java-7","title":"Java 7","text":"<pre><code>StateOwner stateOwner = new StateOwner();\nstateOwner.addStateListener(new StateChangeListener() {\npublic void onStateChange(State oldState, State newState) {\nSystem.out.println(\"State changed\");\n}\n});\n</code></pre>"},{"location":"2022%20WS/06%20Innere%20Klassen/Lambda/#java-8","title":"Java 8+","text":"<pre><code>StateOwner stateOwner = new StateOwner();\nstateOwner.addStateListener(\n(oldState, newState) -&gt; System.out.println(\"State changed\")\n);\n// ODER\nstateOwner.addStateListener((oldState, newState) -&gt; {\nSystem.out.println(\"State changed\");\n});\n</code></pre>"},{"location":"2022%20WS/06%20Innere%20Klassen/Lambda/#python","title":"Python","text":"<pre><code>lambda ARGS : COMPUTATION\n\ndef anonymous(ARGS):\n    COMPUTATION\n</code></pre>"},{"location":"2022%20WS/07%20Ausnahmen/Exceptions/","title":"Exceptions","text":""},{"location":"2022%20WS/07%20Ausnahmen/Exceptions/#hierarchie","title":"Hierarchie","text":"<ul> <li><code>Error</code> = Problem in der JVM<ul> <li>sollten nicht gecatcht werden</li> </ul> </li> <li><code>Exception</code> = Problem im Java-Code<ul> <li><code>RuntimeException</code>: Laufzeitfehler (k\u00f6nnen gecatcht werden)</li> <li>Andere: sollten gecatcht werden</li> </ul> </li> </ul> <pre><code>try {\nint ergebnis = 5 / 0; // wird Ausnahme werfen\n}\ncatch (ArithmeticException e) {\nSystem.out.println(\"Kann nicht durch 0 dividieren.\");\nthrow e; // rethrow\n}\nfinally {\n// \"Aufr\u00e4umarbeiten\"\n}\n</code></pre>"},{"location":"2022%20WS/08%20Streams%20und%20IO/Altklausuren/","title":"Altklausuren","text":""},{"location":"2022%20WS/08%20Streams%20und%20IO/Dateien/","title":"Dateien","text":"<p>Datei: Generell eine (unstrukturierte) Folge von Bytes. Dateizeiger: Byte-Position, an der aktuell gelesen/geschrieben wird.</p>"},{"location":"2022%20WS/08%20Streams%20und%20IO/Dateien/#operationen","title":"Operationen","text":"<p>Dateien m\u00fcssen \"ge\u00f6ffnet\" sein, um Daten lesen und schreiben zu k\u00f6nnen. Danach m\u00fcssen sie wieder \"geschlossen\" werden.</p> <ul> <li>\u00d6ffnen - \"open\"<ul> <li>Es wird ein sogenannter Dateipuffer eingerichtet, um schneller auf die Daten einer Datei zugreifen zu k\u00f6nnen</li> </ul> </li> <li>Lesen - \"read\" (Bytes werden aus einer Datei geladen)<ul> <li>Es ist nicht m\u00f6glich, den Dateizeiger \u00fcber das Ende der Datei (EOF = End-of-File) hinaus zu schieben.</li> </ul> </li> <li>Schreiben - \"write\" (Bytes werden in einer Datei ver\u00e4ndert)<ul> <li>Wenn der Dateizeiger hinter EOF positioniert ist, werden Daten an eine Datei angeh\u00e4ngt.</li> </ul> </li> <li>Suchen - \"seek\" (Die Position des Dateizeigers wird ver\u00e4ndert)</li> <li>Schlie\u00dfen - \"close\"<ul> <li>Speichert die ge\u00e4nderten Daten schlie\u00dflich auf der Festplatte.</li> </ul> </li> </ul>"},{"location":"2022%20WS/08%20Streams%20und%20IO/Dateien/#in-java","title":"In Java","text":"<p>Datei-Operationen werden durch zwei spezielle Streams erm\u00f6glicht.</p> <ol> <li><code>FileInputStream</code> - Aus dem Strom k\u00f6nnen Daten entnommen/gelesen werden</li> <li><code>FileOutputStream</code> - In den Strom k\u00f6nnen Daten hinzugef\u00fcgt/geschrieben werden.</li> </ol> <p>Bei Textdateien sollten bestimmte Klassen genutzt werden.</p> <p><pre><code>public static void main(String[] args) throws IOException {\n// \"open\"\n// DATEISTR\u00d6ME f\u00fcr die EIN- und AUSGABE werden erzeugt.\nFileInputStream in = new FileInputStream(\"datei.txt\");\nFileOutputStream out = new FileOutputStream(\"kopierte_datei.txt\");\n\n// \"read\"\n// Der erste Byte wird aus der Warteschlange des EINGABE-STROMS entnommen.\nint dataByte = in.read();\n\nwhile (b != -1) {\n// \"write\"\n// Der gelesene Byte wird in die Warteschlange des AUSGABE-STROMS hinzugef\u00fcgt.\nout.write(b);\n\n// \"read\"\n// Der n\u00e4chste Byte wird aus dem EINGABE-STROM entnommen.\nb = in.read();\n}\n\n// \"close\"\n// Dateioperationen sind fertig - Alle Streams sollten GESCHLOSSEN werden.\nin.close();\nout.close();\n}\n</code></pre> Beispiel: Die Datei \"datei.txt\" wird in eine andere Datei \"kopierte_datei.txt\" kopiert.</p>"},{"location":"2022%20WS/08%20Streams%20und%20IO/JSON/","title":"JSON","text":"<p>JavaScript Object Notation.</p> <ul> <li>Sehr leicht von Menschen (und unterschiedlichen Anwendungen) lesbar</li> <li>Kann auch von Java geschrieben und gelesen werden mit dem Package <code>org.json</code></li> </ul> <pre><code>{\n\"employees\": [\n{\n\"firstName\": \"John\",\n\"lastName\": \"Doe\"\n},\n{\n\"firstName\": \"Anna\",\n\"lastName\": \"Smith\"\n},\n{\n\"firstName\": \"Peter\",\n\"lastName\": \"Jones\"\n}\n]\n}\n</code></pre>"},{"location":"2022%20WS/08%20Streams%20und%20IO/Serialisierung/","title":"Serialisierung","text":"<p>Das Konvertieren von einem Objekt --&gt; Bytes, die z.B. auf der Festplatte gespeichert werden k\u00f6nnen.</p> <p>Die gelagerten Bytes k\u00f6nnen danach wieder deserialisiert werden (Bytes --&gt; Objekt).</p>"},{"location":"2022%20WS/08%20Streams%20und%20IO/Serialisierung/#algorithmus-der-serialisierung","title":"Algorithmus der Serialisierung","text":"<p>Algorithmus, um ein bestimmtes Objekt in Bytes zu verwandeln.</p> <ol> <li>Erzeuge und Schreiben einer ID (\"eindeutige Seriennummer\") f\u00fcr das Objekt</li> <li>Schreiben der Klasseneigenschaften (Klassenname, Attributnamen und -typen)</li> <li>Schreiben der Attributwerte<ol> <li>Falls es sich um einen primitiven Typen handelt, schreibe ihn direkt</li> <li>Falls es sich um eine Referenz handelt...<ol> <li>Falls die Referenz noch nicht serialisiert ist: Serialisiere die Referenz (rekursiv!)</li> <li>Falls die Referenz bereits geschrieben wurde, schreibe ihre ID</li> </ol> </li> </ol> </li> </ol> <p>Eine Klasse ist nur serialisierbar, wenn...</p> <ol> <li>Sie das Marker-Interface <code>Serializable</code> implementiert</li> <li>In ihren Attributen ausschlie\u00dflich primitive Datentypen und serialisierbare Objekte stehen</li> </ol>"},{"location":"2022%20WS/08%20Streams%20und%20IO/Serialisierung/#de-serialisierung-mit-datenstrom","title":"(De-)Serialisierung mit Datenstrom","text":"<p>In Java k\u00f6nnen serialisierbare Objekte mithilfe von <code>ObjectOutputStream</code> in einen Byte-Datenstrom konvertiert werden.</p> <pre><code>class ObjectOutputStream {\n// Konstruktor\nObjectOutputStream(OutputStream stream) throws IOException {...}\n\n// Schreibt \"obj\" in den Strom\nvoid writeObject(Serializable obj) throws IOException {...}\n\n// Setzt alle Referenzen zur\u00fcck, die bereits geschriebenen wurden\nvoid reset() throws IOException {...}\n}\n</code></pre> <p>Zum Deserialisieren kann die Klasse <code>ObjectInputStream</code> benutzt werden.</p> <pre><code>class ObjectInputStream {\n// Konstruktor\nObjectInputStream(InputStream in) throws IOException {...}\n\n// Liest das n\u00e4chste Objekt aus dem Byte-Datenstrom und gibt es zur\u00fcck\nObject readObject() throws IOException {...}\n}\n</code></pre> <p>Beispiel: <pre><code>// Speichert einen Studenten in die Datei \"savefile.ser\"\npublic void writeStudentToFile() {\nObjectOutputStream objectStream;\n\ntry {\nStudent s = new Student(\"Hugo\", \"Test\", 12345678);\ns.setNote(1.3);\n\nFileOutputStream fileStream = new FileOutputStream(\"savefile.ser\");\nobjectStream = new ObjectOutputStream(fileStream);\nobjectStream.writeObject(s);\n} finally {\nobjectStream.close();\n}\n}\n\n// Liest das erste Objekt aus der Datei \"savefile.ser\" und gibt es zur\u00fcck\npublic Student readStudentFromFile() {\nObjectInputStream objectStream;\n\ntry {\nFileInputStream fileStream = new FileInputStream(\"savefile.ser\");\nobjectStream = new ObjectInputStream(fileStream);\n\nObject deserialized = objectStream.readObject();\nreturn (Student) deserialized; // Explizites Downcasting\n} finally {\nobjectStream.close();\n}\n}\n</code></pre></p>"},{"location":"2022%20WS/08%20Streams%20und%20IO/Serialisierung/#grenzen-der-serialisierung","title":"Grenzen der Serialisierung","text":"<ul> <li>Wenn der Quellcode einer Klasse abge\u00e4ndert wird, k\u00f6nnen vorher gespeicherte Bytes nicht mehr in die Klasse konvertiert werden.</li> <li>Aus gespeicherten Bytes k\u00f6nnen andere Anwendungen nur sehr schwer die Daten importieren.</li> </ul>"},{"location":"2022%20WS/08%20Streams%20und%20IO/Standard-Datenstr%C3%B6me/","title":"Standard-Datenstr\u00f6me","text":"<p>In Java gibt es 3 Standard-Datenstr\u00f6me f\u00fcr die Ein-/Ausgabe von Nachrichten in der Konsole.</p>"},{"location":"2022%20WS/08%20Streams%20und%20IO/Standard-Datenstr%C3%B6me/#input","title":"Input","text":"<p>Der Standard-Datenstrom <code>System.in</code> kann Nachrichten verarbeiten, die in der Konsole eingegeben werden.</p>"},{"location":"2022%20WS/08%20Streams%20und%20IO/Standard-Datenstr%C3%B6me/#output","title":"Output","text":"<p>Die normale Ausgabe von <code>println</code>-Befehlen funktioniert \u00fcber den Datenstrom <code>System.out</code> in Java.</p> <p>Fehlernachrichten und Ausnahmen werden \u00fcber einen weiteren Datenstrom namens <code>System.err</code> ausgegeben. Diese Nachrichten werden in der Konsole in roter Farbe angezeigt.</p> <pre><code>// EINGABE\nSystem.in.read(...);\n\n// AUSGABE (NACHRICHTEN)\nSystem.out.println(\"Hello World\");\n\n// AUSGABE (FEHLER)\nSystem.err.println(\"Fehler!!!\");\n</code></pre>"},{"location":"2022%20WS/08%20Streams%20und%20IO/Streams/","title":"Streams","text":"<p>Ein Stream ist eine Datenstruktur \u00e4hnlich wie eine Queue/Warteschlange.</p> <p>Streams besitzen zwei Seiten:</p> <ol> <li>Quelle: Hier werden Daten in die Queue hinzugef\u00fcgt.</li> <li>Senke: Hier werden Daten aus der Queue entfernt.</li> </ol> <p></p> <p>In Java werden Streams f\u00fcr verschiedene Operationen verwendet.</p> <ol> <li>Ein-/Ausgabe \u00fcber die Konsole (Standard-Datenstr\u00f6me <code>System.in</code>/<code>System.out</code>/<code>System.err</code>)</li> <li>Laden/Speichern von Dateien (<code>FileInputStream</code>, <code>FileOutputStream</code>)</li> </ol>"},{"location":"2022%20WS/08%20Streams%20und%20IO/Textdateien/","title":"Textdateien","text":"<p>Zum Lesen/Schreiben einer Textdatei sollten in Java bestimmte Klassen verwendet werden:</p> <ol> <li><code>BufferedReader</code> - erm\u00f6glicht das Lesen einzelner Textzeilen</li> <li><code>PrintWriter</code> - erm\u00f6glicht das formatierte Schreiben von Daten/Objekten</li> </ol>"},{"location":"2022%20WS/09%20Datenstrukturen/B%C3%A4ume/","title":"B\u00e4ume","text":"<p>Von einem Wurzelknoten ausgehend hat ein Baum untergeordnete Kinderknoten.</p>"},{"location":"2022%20WS/09%20Datenstrukturen/B%C3%A4ume/#traversierung","title":"Traversierung","text":"<pre><code>   M\n /   \\\nL     R\n</code></pre> <ul> <li>Breadth-First (Breiten-Traversierung)<ul> <li>Realisiert durch Queue</li> </ul> </li> <li>Depth-First (Tiefen-Traversierung)<ul> <li>In Order ( L M R )</li> <li>Pre Order ( M L R )</li> <li>Post Order ( L R M )</li> <li>Realisiert durch Stack</li> </ul> </li> </ul>"},{"location":"2022%20WS/09%20Datenstrukturen/B%C3%A4ume/#binarer-suchbaum-bst","title":"Bin\u00e4rer Suchbaum (BST)","text":"<p>Ein bin\u00e4rer Suchbaum hat folgende Eigenschaften:</p> <ul> <li>Jeder Knoten hat maximal 2 Kinder (\"links\" und \"rechts\")</li> <li>F\u00fcr einen Knoten mit Wert N gilt<ul> <li>Alle untergeordneten Knoten auf der linken Seite haben einen Wert \u2264 N</li> <li>Alle untergeordneten Knoten auf der rechten Seite haben einen Wert \u2265 N</li> <li>Dadurch bleibt ein bin\u00e4rer Suchbaum immer sortiert</li> </ul> </li> </ul>"},{"location":"2022%20WS/09%20Datenstrukturen/Graphen/","title":"Graphen","text":"<p>Siehe Graph.</p> <p>Weitere Eigenschaften eines Graphen:</p> <ul> <li>Grad/Valenz - Anzahl der verbundenen Kanten an einem Knoten<ul> <li>Gerichtete Graphen haben dabei Eingangsgrad und Ausgangsgrad</li> </ul> </li> <li>Ein Graph hei\u00dft \"regul\u00e4r\", wenn alle Knoten denselben Grad haben</li> <li>Gewichtete Graphen</li> </ul>"},{"location":"2022%20WS/09%20Datenstrukturen/Graphen/#untergraphen-und-teilgraphen","title":"Untergraphen und Teilgraphen","text":"<p>Sei G ein Graph. G kann als \"Obergraph\" bezeichnet werden. Wenn Knoten oder Kanten aus diesem Obergraph entfernt werden, bildet sich ein neuer Teilgraph von G.</p> <p>Spezieller Fall \"Untergraph\" - Es werden Knoten aus dem Obergraphen entfernt, aber so viele Kanten wie m\u00f6glich beibehalten.</p>"},{"location":"2022%20WS/09%20Datenstrukturen/Graphen/#wege-und-pfade","title":"Wege und Pfade","text":"<p>Ein Weg ist eine Aneinanderreihung von Knoten, die jeweils durch Kanten verbunden sind.</p> <p>Spezieller Fall \"Pfad\" - Es gibt keine doppelten Knoten in der Aneinanderreihung. Spzieller Fall \"Eulerscher Weg\" - Es werden alle Kanten verwendet. Falls der Endknoten gleichzeitig auch der Startknoten ist, spricht man von einem \"Eulerschen Kreis\".</p>"},{"location":"2022%20WS/09%20Datenstrukturen/Graphen/#traversierung","title":"Traversierung","text":"<p>Graphen k\u00f6nnen im Gegensatz zu B\u00e4umen sogenannte Zyklen enthalten.</p> <ul> <li>Breitensuche - Umgesetzt durch Queue</li> <li>Tiefensuche - Umgesetzt durch Stack</li> </ul>"},{"location":"2022%20WS/09%20Datenstrukturen/Graphen/#umsetzung","title":"Umsetzung","text":"<ul> <li>Adjazenzliste - Pro Knoten werden die verbundenen Endknoten gespeichert<ul> <li>Statische Adjazenzliste - Nutzung von Arrays</li> <li>Dynamische Adjazenzliste - Nutzung von Linked Lists</li> </ul> </li> <li>Adjazenzmatrix - 2-dimensionelles Array (abbildende \"Tabelle\") zur Beschreibung von Kanten</li> </ul>"},{"location":"2022%20WS/09%20Datenstrukturen/Weitere%20Listen/","title":"Weitere Listen","text":"<p>Verschiedene Typen von Listen.</p>"},{"location":"2022%20WS/09%20Datenstrukturen/Weitere%20Listen/#linked-list","title":"Linked List","text":"<p>Eine Linked List beinhaltet nur eine Referenz auf das erste Element (\"head\"). Dieses Element kann dann auf den n\u00e4chsten Eintrag in der Liste verweisen.</p>"},{"location":"2022%20WS/09%20Datenstrukturen/Weitere%20Listen/#doppelte-linked-list","title":"Doppelte Linked List","text":"<p>Eine #Linked List, wobei jedes Element der Liste beinhaltet eine Referenz auf das n\u00e4chste Element und das vorherige Element.</p>"},{"location":"2022%20WS/09%20Datenstrukturen/Weitere%20Listen/#circular-linked-list","title":"Circular Linked List","text":"<p>Eine Circular Linked List ist ein geschlossener \"Ring\" von Elementen.</p> <ul> <li>Das letzte Element der Liste zeigt wieder auf das erste Element</li> <li>Kann mit #Linked List oder #Doppelte Linked List umgesetzt werden</li> </ul>"},{"location":"2022%20WS/09%20Datenstrukturen/Weitere%20Listen/#stack","title":"Stack","text":"<p>Implementiert LIFO (\"Last in, first out\").</p> <ul> <li><code>push(&lt;ELEMENT&gt;)</code> - Element auf den Stack legen</li> <li><code>pop()</code> - Oberstes Element aus dem Stack entnehmen</li> <li><code>peek() / top()</code> - Oberstes Element aus dem Stack zur\u00fcckgeben, aber nicht entnehmen</li> </ul>"},{"location":"2022%20WS/09%20Datenstrukturen/Weitere%20Listen/#queue","title":"Queue","text":"<p>Implementiert FIFO (\"First in, first out\").</p> <ul> <li><code>enqueue(&lt;ELEMENT&gt;)</code> - Element an das Ende der Queue anh\u00e4ngen</li> <li><code>dequeue()</code> - Vorderstes Element aus der Queue entnehmen</li> <li><code>front()</code> - Vorderstes Element zur\u00fcckgeben, aber nicht entnehmen</li> <li><code>rear()</code> - Hinterstes Element zur\u00fcckgeben</li> </ul>"},{"location":"2022%20WS/10%20Hashing/Hashing/","title":"Hashing","text":"<p>Hashfunktionen und deren Anwendung.</p> <p>Anwendungen</p> <ul> <li>Pr\u00fcfsummen - Schnelles \u00dcberpr\u00fcfen der Richtigkeit von ISBN oder Kontonummern durch Modulorechnung</li> <li>Kryptologie - Einseitiges Verschl\u00fcsseln von Passw\u00f6rtern</li> </ul> <p>Kriterien f\u00fcr einen guten Hashalgorithmus</p> <ol> <li>Streuung - M\u00f6glichst gleichverteilte Hashwerte f\u00fcr erwartete Eingaben (weniger Kollisionen)</li> <li>Datenreduktion - Ein Hashwert soll weniger Speicher verbrauchen als die Eingabe</li> <li>Chaos - M\u00f6glichst verschiedene Hashwerte f\u00fcr \u00e4hnliche Eingaben<ul> <li>\u00c4ndern eines einzigen Eingabe-Bits sollte durchschnittlich die H\u00e4lfte aller Hashwert-Bits ver\u00e4ndern</li> </ul> </li> <li>Surjektivit\u00e4t - M\u00f6glichst viele theoretische Hashwerte</li> <li>Effizienz - M\u00f6glichst schnell zu berechnen</li> <li>Ordnungserhaltend - Bei sortiertem Zugriff auf Hashtabelle</li> </ol>"},{"location":"2022%20WS/11%20Backtracking/Algorithmus/","title":"Algorithmus","text":"<p>Ein Algorithmus beschreibt, wie ein konkretes Problem gel\u00f6st werden soll \u2013 und zwar exakt. Er besteht aus einer endlichen Abfolge von Anweisungen.</p> <p>Erforderliche Eigenschaften</p> <ol> <li>Finit - Mit endlichem Text eindeutig beschreibbar</li> <li>Dynamisch finit - Endlicher Speicherbedarf</li> <li>Ausf\u00fchrbar - Jeder Schritt muss ausf\u00fchrbar sein</li> <li>Terminierend - Es werden nur endliche Schritte ben\u00f6tigt</li> </ol> <p>Weitere m\u00f6gliche Eigenschaften</p> <ol> <li>Determiniertheit - Gleiche Eingabe liefert immer das gleiche Ergebnis</li> <li>Deterministisch - Der n\u00e4chste Programmschritt ist immer eindeutig definiert</li> </ol>"},{"location":"2022%20WS/11%20Backtracking/Algorithmus/#strategien","title":"Strategien","text":"<p>Algorithmen nach Strategien kategorisiert.</p> <ol> <li>Brute Force - Alle m\u00f6glichen L\u00f6sungen unintelligent generieren und alle versuchen</li> <li>Backtracking - Systematisch und schrittweise (vor und zur\u00fcck) m\u00f6gliche L\u00f6sungen generieren</li> <li>Divide and Conquer - Problem rekursiv in unabh\u00e4ngige Unterprobleme teilen und dann zusammenf\u00fcgen</li> <li>Dynamische Programmierung - Optimierungsproblem rekursiv in \u00fcberlappende Unterprobleme teilen und dann zusammenf\u00fcgen</li> <li>Greedy - Immer den n\u00e4chstbesten Schritt ohne zur\u00fcckzugehen</li> <li>Branch and Bound - Backtracking bei Optimierungsproblemen</li> <li>Hill Climbing - Optimierungsproblem durch evolution\u00e4re Verbesserungen l\u00f6sen</li> <li>Particle Swarm - Dezentalisierte \"Partikel\", die organisiert auf unterschiedliche Weise eine L\u00f6sung suchen</li> </ol>"},{"location":"2022%20WS/11%20Backtracking/Backtracking/","title":"Backtracking","text":"<p>Backtracking funktioniert wie Tiefensuche in einem Baum. Es werden alle n\u00e4chsten Schritte (Kindknoten) betrachtet und der erste \"m\u00f6gliche\" Schritt genommen. Falls ein Schritt als \"unm\u00f6glich\" markiert ist, wird r\u00fcckg\u00e4ngig gegangen und der n\u00e4chste Schritt \u00fcberpr\u00fcft.</p> <p>Anwendung oft bei Spielen wie Schach oder Sudoku.</p> <p></p>"},{"location":"2022%20WS/12%20Greedy/Dijkstra-Algorithmus/","title":"Dijkstra-Algorithmus","text":"<p>Der Dijkstra-Algorithmus findet die k\u00fcrzesten Pfade von einem gew\u00e4hlten Startknoten zu allen anderen Knoten eines Graphen.</p> <p>Zu jedem Knoten werden zwei Dinge gespeichert.</p> <ul> <li>Die Pfadl\u00e4nge zum Startknoten (anfangs \\(\\infty\\))</li> <li>Der Vorl\u00e4ufer-Knoten in seinem Pfad (anfangs <code>null</code>)</li> </ul> <p></p> <ol> <li>Setze die Pfadl\u00e4nge des Startknoten auf 0</li> <li>Schleife: bis keine Knoten mehr \u00fcbrig sind<ol> <li>Entnehme den Knoten mit der kleinsten Pfadl\u00e4nge (effizient mit \"Priority Queue\")</li> <li>Schleife: f\u00fcr alle anschlie\u00dfenden Kanten des entnommenen Knoten<ol> <li>Sei \\(w\\) = (Pfadl\u00e4nge des entnommenen Knoten + Gewicht der Kante)</li> <li>Falls \\(w\\) &lt; Pfadl\u00e4nge des anderen Knoten:<ol> <li>Setze die Pfadl\u00e4nge des anderen Knoten auf \\(w\\)</li> <li>Trage als Vorl\u00e4ufer des anderen Knoten den entnommenen Knoten ein</li> </ol> </li> </ol> </li> </ol> </li> </ol> <p></p> Iteration Betrachteter Knoten Pfadl\u00e4nge und Vorl\u00e4ufer der jeweiligen Knoten 0 - <code>s( 0,- ) t( \u221e,-) x( \u221e,-) y( \u221e,-) z( \u221e,-)</code> 1 \\(s\\) <code>-------- t(10,s) x( \u221e,-) y( 5,s) z( \u221e,-)</code> 2 \\(y\\) <code>-------- t( 8,s) x(14,y) ------- z( 7,y)</code> 3 \\(z\\) <code>-------- t( 8,s) x(13,y) ------- -------</code> 4 \\(t\\) <code>-------- ------- x( 9,y) ------- -------</code> <p>Am Ende beinhaltet jeder Knoten des Graphen die minmale Pfadl\u00e4nge zum Startknoten und den jeweiligen Vorl\u00e4ufer-Knoten seines minimalen Pfades.</p>"},{"location":"2022%20WS/12%20Greedy/Greedy/","title":"Greedy","text":"<p>Greedy-Algorithmen nehmen immer die Entscheidung, die in dem Moment am besten aussieht.</p> <p>Im Gegensatz zu Backtracking gehen Greedy-Algorithmen nie R\u00fcckw\u00e4rtsschritte.</p> <p>Anwendung in Graph-Algorithmen</p> <ul> <li>Minimalen Spannbaum (MST) berechnen - Kruskal, Prim</li> <li>K\u00fcrzesten Weg finden - Dijkstra</li> </ul>"},{"location":"2022%20WS/12%20Greedy/Komplexit%C3%A4tsberechnung/","title":"Komplexit\u00e4tsberechnung","text":"<p>Es gibt drei Methoden zur Komplexit\u00e4tsberechnung bei Rekursionen.</p>"},{"location":"2022%20WS/12%20Greedy/Komplexit%C3%A4tsberechnung/#substitution-induktion","title":"Substitution (Induktion)","text":"<p>Aus den Laufzeit-Komponenten eines Algorithmus wird eine rekursive Funktion gebildet. Aus dieser Funktion wird eine Komplexit\u00e4t eingesch\u00e4tzt und dann induktiv bewiesen.</p> <ul> <li>Rekursive Formel: z.B. \\(T(n) = 2T(n/2) + n\\)</li> <li>Gesch\u00e4tzte Komplexit\u00e4t der Formel: \\(\\Theta(n \\log{n})\\)</li> <li>Induktion: Beweisen von \\(T(n) \\leq c * n \\log{n}\\) (Komplexit\u00e4t multipliziert mit einer Konstante)</li> </ul>"},{"location":"2022%20WS/12%20Greedy/Komplexit%C3%A4tsberechnung/#rekurrenzbaum","title":"Rekurrenzbaum","text":"<p>Darstellung der Teilprobleme als einzelne Knoten eines Baums. Jeder Teilproblem-Knoten ist beschriftet mit seinem \"Arbeitsaufwand\" (Komplexit\u00e4t).</p> <ul> <li>Die Komplexit\u00e4t von Bl\u00e4ttern ist \\(\\Theta(1)\\)</li> <li>Gesamtkomplexit\u00e4t durch Addition aller Knoten</li> </ul> <p></p>"},{"location":"2022%20WS/12%20Greedy/Komplexit%C3%A4tsberechnung/#master-theorem","title":"Master-Theorem","text":"<p>Diese Methode kann nur genutzt werden, falls der rekursive Algorithmus die folgende Form. \\(\\(T(n) = a * T(n/b) + f(n)\\)\\) Komponenten seien dabei</p> <ul> <li>Anzahl der Teilprobleme pro Rekursionsschritt: \\(a \\geq 1\\)</li> <li>Teilung des Inputs pro Teilrekursion: \\(b &gt; 1\\)</li> </ul> <p>Dann wird zwischen drei F\u00e4llen unterschieden, abh\u00e4ngig von der Komplexit\u00e4t von \\(f(n)\\). \\(\\(f(n) = \\Theta(n^c)\\)\\)</p> <ol> <li>\\(c &lt; \\log_b a \\implies T(n) = \\Theta(n^{\\log_b a})\\)</li> <li>\\(c = \\log_b a \\implies T(n) = \\Theta(n^c * \\log{n})\\)</li> <li>\\(c &gt; \\log_b a \\implies T(n) = f(n)\\)</li> </ol>"},{"location":"2022%20WS/12%20Greedy/Minimaler%20Spannbaum/","title":"Minimaler Spannbaum","text":"<p>Spannbaum - Eine Baum-Struktur, die aus einem gewichteten Graphen entsteht.</p> <p>Ein Spannbaum hei\u00dft \"minimal\", wenn er alle Knoten beinhaltet und die Kanten mit dem kleinstm\u00f6glichen Gesamtgewicht \u00fcbertr\u00e4gt.</p>"},{"location":"2022%20WS/12%20Greedy/Minimaler%20Spannbaum/#kruskal-algorithmus","title":"Kruskal-Algorithmus","text":"<p>Kanten von kleinstem zu gr\u00f6\u00dftem Gewicht sortieren und der Reihenfolge nach in einen Baum \u00fcbertragen.</p> <ol> <li>Alle Kanten des Graphen von kleinstem zu gr\u00f6\u00dftem Gewicht sortieren</li> <li>Schleife: alle Kanten der Reihenfolge nach<ol> <li>\u00dcberpr\u00fcfen, ob die beiden Knoten der Kante schon in Verbindung stehen (\"Find-Union\")</li> <li>Falls nicht: Kante eintragen</li> </ol> </li> </ol> <p>Zyklen m\u00fcssen explizit durch Find-Union vermieden werden.</p> <ul> <li>Alle Knoten besitzen am Anfang eine Menge, die nur den einzelnen Knoten beinhaltet.</li> <li>Mit jeder eingetragenen Kante werden die Mengen beider Knoten vereint.</li> <li>Eine Kante wird \u00fcbersprungen, falls beide Knoten dieselbe Menge besitzen (sonst w\u00fcrde ein Zyklus entstehen).</li> </ul> <p></p>"},{"location":"2022%20WS/12%20Greedy/Minimaler%20Spannbaum/#prim-algorithmus","title":"Prim-Algorithmus","text":"<ol> <li>Ein Startknoten wird gew\u00e4hlt und als besucht markiert</li> <li>Schleife: bis alle Knoten besucht sind<ol> <li>Erreichbare Kanten = Alle Kanten, die von allen besuchten Knoten ausgehen und zu unbesuchten Knoten f\u00fchren</li> <li>Aus den erreichbaren Kanten wird die mit dem kleinsten Gewicht gew\u00e4hlt</li> <li>Die gew\u00e4hlte Kante wird eingetragen und der neue Knoten als besucht markiert</li> </ol> </li> </ol>"},{"location":"2023%20SS/00%20Einleitung/Kommandozeile/","title":"Kommandozeile","text":"<p>Die Kommandozeile ist Bestandteil jedes Betriebssystems. Unter Windows hei\u00dft das Programm f\u00fcr die Kommandozeile \"Eingabeaufforderung\".</p> <p>Beim \u00d6ffnen der Eingabeaufforderung wird das aktuelle Verzeichnis (<code>C:\\Users\\benutzername</code>) angezeigt.</p> <pre><code>Microsoft Windows [Version 10.0.19045.2846]\n(c) Microsoft Corporation. Alle Rechte vorbehalten.\n\nC:\\Users\\benutzername&gt;\n</code></pre>"},{"location":"2023%20SS/00%20Einleitung/Kommandozeile/#befehle","title":"Befehle","text":"<p>In der Kommandozeile k\u00f6nnen Befehle ausgef\u00fchrt werden. Zum Beispiel l\u00e4sst sich mit dem Befehl <code>python</code> der Python Interpreter starten.</p> <pre><code># EINGABE\nC:\\Users\\benutzername&gt; python\n\n# AUSF\u00dcHRUNG DES BEFEHLS \"python\"\nPython 2.7.18 (v2.7.18:8d21aa21f2, Apr 20 2020, 13:25:05) [MSC v.1500 64 bit (AMD64)] on win32\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n&gt;&gt;&gt; print \"Hello\"\nHello\n</code></pre>"},{"location":"2023%20SS/00%20Einleitung/Kommandozeile/#befehle-abbrechen","title":"Befehle abbrechen","text":"<p>Nachdem ein Befehl \u00fcber die Kommandozeile gestartet wurde, kann er jederzeit abgebrochen werden. Um den gestarteten Python Interpreter wieder zu verlassen, kann die Tastenkombination <code>Ctrl C</code> verwendet werden.</p>"},{"location":"2023%20SS/00%20Einleitung/Kommandozeile/#befehle-mit-argumenten-ausfuhren","title":"Befehle mit Argumenten ausf\u00fchren","text":"<p>Beim Ausf\u00fchren eines Befehls k\u00f6nnen Argumente/Parameter angegeben werden.</p> <p>Ein weit verbreiteter Parameter, der von vielen Befehlen akzeptiert wird, ist <code>--help</code>. Mit ihm k\u00f6nnen meistens alle m\u00f6glichen Kommandozeilenparameter eines Befehls ausgegeben werden.</p> <pre><code># EINGABE MIT ARGUMENT/PARAMETER\nC:\\Users\\benutzername&gt; python --help\n\n# AUSF\u00dcHRUNG DES BEFEHLS \"python --help\"\nusage: C:\\...\\bin\\python.exe [option] ... [-c cmd | -m mod | file | -] [arg] ...\nOptions and arguments (and corresponding environment variables)\n-b     : issue warnings about comparing bytearray with unicode\n(-bb issue errors)\n\n...\n\n-u     : unbuffered binary stdout and stderr; also PYTHONUNBUFFERED=x\nsee man page for details on internal buffering relating to '-u'\n-v     : verbose (trace import statements); also PYTHONVERBOSE=x\ncan be supplied multiple times to increase verbosity\n-V     : print the Python version number and exit (also --version)\n</code></pre> <p>Hier wird zum Beispiel das Argument <code>-V</code> genannt, um die Python-Version auszugeben.</p> <pre><code># EINGABE MIT ARGUMENT/PARAMETER\nC:\\Users\\benutzername&gt; python -V\n\n# AUSF\u00dcHRUNG DES BEFEHLS \"python -V\"\nPython 2.7.18\n</code></pre> <p>In komplexeren Programmen werden teilweise viele verschiedene Argumente in einen einzelnen Befehlsaufruf geschrieben. Mit dem Programm <code>ffmpeg</code> kann zum Beispiel durch den folgenden Befehl das Format einer Videodatei von AVI zu MP4 mit einer Aufl\u00f6sung von 1920x1080 Pixeln konvertiert werden:</p> <pre><code>ffmpeg -i input.avi -s 1920x1080 output.mp4\n</code></pre> <p>In dem Beispiel gibt es 5 Argumente: <code>-i</code>, <code>input.avi</code>, <code>-s</code>, <code>1920x1080</code> und <code>output.mp4</code>.</p> <p>Argumente, die auf diese Weise angegeben werden, k\u00f6nnen vom jeweiligen Befehl/Programm (in dem Fall <code>ffmpeg</code> oder <code>python</code>) gelesen und interpretiert werden.</p>"},{"location":"2023%20SS/00%20Einleitung/Kommandozeile/#argumente-in-eigenen-programmen","title":"Argumente in eigenen Programmen","text":"<p>Auch selbst geschriebene Programme in Java, C, Python usw. k\u00f6nnen Argumente auf eigene Weise verarbeiten. Meistens wird direkt in der statischen <code>main()</code>-Methode ein Array an Strings \u00fcberliefert, der die Befehls-Argumente enth\u00e4lt.</p> <pre><code>// Dateiname: \"MainClass.java\"\npublic class MainClass {  public static void main(String[] arguments) {  System.out.println(\"Es gibt \" + arguments.length + \" Argumente\");  // Hier werden alle angegebenen Argumente in die Programmausgabe geschrieben.  \nfor (String argument : arguments) {  System.out.println(\"Argument: \" + argument);  }  }  }\n</code></pre> <p>Dieses Java-Programm kann von der Kommandozeile mit dem folgenden Befehl ausgef\u00fchrt werden:</p> <pre><code>java MainClass.java\n</code></pre> <p>Hinter diesen Befehl k\u00f6nnen nun beliebig viele Argumente angeh\u00e4ngt werden, zum Beispiel \"mein-erstes-argument\" und \"Nummer2\".</p> <pre><code># EINGABE\nC:\\Users\\benutzername\\JavaBeispiel&gt; java MainClass.java mein-erstes-argument Nummer2\n\n# AUSF\u00dcHRUNG DES BEFEHLS \"java MainClass.java mein-erstes-argument Nummer2\"\nEs gibt 2 Argumente\nArgument: mein-erstes-argument\nArgument: Nummer2\n</code></pre>"},{"location":"2023%20SS/00%20Einleitung/Kommandozeile/#argumente-als-zahlen-interpretieren","title":"Argumente als Zahlen interpretieren","text":"<p>Programm-Argumente werden als eine Anreihung von Zeichenketten \u00fcbergeben (Typ <code>String[]</code>).</p> <p>Falls man ein Programm gestaltet, das eingegebene Zahlen verarbeiten soll, m\u00fcssen die Argumente von dem Typ <code>String</code> in den Typ <code>int</code> oder <code>float</code> konvertiert werden.</p> <p>In Java geht das mithilfe der statischen Methoden <code>Integer.parseInt()</code> oder <code>Float.parseFloat()</code> (Siehe auch: H\u00fcllenklasse)</p> <pre><code>String geschriebeneZahl = \"12\";\n\nint zahl = Integer.parseInt(geschriebeneZahl);       // 12\nfloat dezimal = Float.parseFloat(geschriebeneZahl);  // 12.0\n</code></pre>"},{"location":"2023%20SS/00%20Einleitung/Programmiersprachen%20der%20Vorlesung/","title":"Programmiersprachen der Vorlesung","text":"<p>In Informatik 3 werden folgende Programmiersprachen beachtet:</p> <ul> <li>C++</li> <li>C#</li> <li>Java</li> <li>Python</li> </ul>"},{"location":"2023%20SS/00%20Einleitung/Programmierung/","title":"Programmierung","text":""},{"location":"2023%20SS/00%20Einleitung/Programmierung/#definitionen","title":"Definitionen","text":"<p>Programmiersprache Formale Sprache zur Darstellung von Modellen (Programmen) ausf\u00fchrbar auf Rechnern.</p> <p>Programm Maschinell bearbeitbare L\u00f6sung eines informatischen Problems.</p> <p>Programmieren Programme erstellen, aber auch analysieren, spezifizieren, entwerfen, implementieren und testen.</p>"},{"location":"2023%20SS/00%20Einleitung/Programmierung/#klassifikation-von-programmiersprachen","title":"Klassifikation von Programmiersprachen","text":"<p>Programmiersprachen k\u00f6nnen grob in 3 Abstraktionsebenen geteilt werden:</p> <ul> <li>H\u00f6here Programmiersprachen (Python, C++, Java)</li> <li>Assemblersprachen (Assembler)</li> <li>Maschinensprachen</li> </ul>"},{"location":"2023%20SS/01%20Programmierparadigmen/Funktionale%20Programmierung/","title":"Funktionale Programmierung","text":"<p>Die funktionale Programmierung ist \u00e4hnlich wie das Umformen und L\u00f6sen von mathematischen Ausr\u00fccken. Jeder Ausdruck kann so lange aufgel\u00f6st werden, bis am Ende nur ein einziger konstanter Wert da steht.</p> \\[f(x) = -x^3$$ $$g(x) = x + 5\\] <p>Die beiden Funktionen \\(f(x)\\) und \\(g(x)\\) k\u00f6nnen ineinander oder unabh\u00e4ngig voneinander zu einem Ergebnis umgeformt werden.</p> \\[ \\begin{align} f(g(2)) &amp;= f(2 + 5)\\\\ &amp;= f(7)\\\\ &amp;= -7^3\\\\ &amp;= -343 \\end{align} \\] <p>Hier wird der mathematische Ausdruck \\(f(g(2))\\) zu einem konstanten Ergebnis \\(-343\\) aufgel\u00f6st.</p> <p>In der funktionalen Programmierung werden keine Variablen definiert oder zugewiesen - es gibt keine Variablen. Stattdessen gibt es ausschlie\u00dflich Konstanten und Funktionen. Jede Funktion liefert auf eine Eingabe immer eine vorhersehbare Ausgabe. Funktional geschriebene Programme sind zustandlos und k\u00f6nnen deswegen keine Nebeneffekte haben.</p> <p>Obwohl die Programmiersprachen der Vorlesung objektorientierte Sprachen sind, ist es trotzdem m\u00f6glich, das Programmierparadigma der funktionalen Programmierung umzusetzen. Entscheidend f\u00fcr das Paradigma ist die folgende Eigenschaft: Es d\u00fcrfen keine Variablen angelegt werden - nur die Parameter und die R\u00fcckgabe einer Funktion dienen als Werte. Deshalb werden in der funktionalen Programmierung Algorithmen nur in rekursiver Form formuliert.</p> <pre><code>public static float f(float x) {\nreturn -(x * x * x); // -x\u00b3\n}\n\npublic static float g(float x) {\nreturn x + 5;\n}\n\n\npublic static void main(String[] args) {\nSystem.out.println(  f(g(2))  );  // Gibt \"-343\" in der Konsole aus\n}\n</code></pre> <p>Hier wurden die oberen Funktionen \\(f(x)\\) und \\(g(x)\\) in Java umgesetzt. Der funktionale Ansatz bleibt dabei erhalten, da die Funktionen ausschlie\u00dflich daraus bestehen, einen Wert zur\u00fcckgeben.</p>"},{"location":"2023%20SS/01%20Programmierparadigmen/Imperative%20Programmierung/","title":"Imperative Programmierung","text":"<p>Imperative Programme besitzen sogenannte dynamische Programmzust\u00e4nde und hei\u00dfen auch zustandsorientiert.Programmzust\u00e4nde k\u00f6nnen innerhalb des Programms zugewiesen oder als Werte genutzt werden. Zu Programmzust\u00e4nden geh\u00f6ren zum Beispiel die Attribute eines Objekts oder die hochz\u00e4hlende Variable einer <code>for</code>-Schleife.</p> <p>Die Grundidee der imperativen Programmierung ist, dass man die Funktionsaufrufe der funktionalen Programmierung durch die Erzeugung von Objekten und durch das Zuweisen von Programmzust\u00e4nden ersetzt.</p> <p>In der imperativen Programmierung entscheidet man zwischen zwei Arten von Operationen:</p> <ol> <li>Abfrage - Es wird ein Programmzustand zur\u00fcckgeliefert.</li> <li>Aktion - Es wird ein Programmzustand ver\u00e4ndert oder zugewiesen.<ul> <li>Jede Ausf\u00fchrung eines Befehls \u00e4ndert den Zustand des Programms.   Zum Beispiel kann mehrmals der Befehl <code>i = i + 1</code> ausgef\u00fchrt werden, und der Zustand der Variable <code>i</code> \u00e4ndert sich jedes Mal.</li> </ul> </li> </ol> <p>Ein imperatives Programm ist nichts weiteres als eine Abfolge von Abfragen und Aktionen.</p>"},{"location":"2023%20SS/01%20Programmierparadigmen/Imperative%20Programmierung/#nebeneffekte","title":"Nebeneffekte","text":"<p>Ein Nebeneffekt ist eine Aktion, die neben der Hauptoperation ausgef\u00fchrt wird. Ein Programmzustand wird also ver\u00e4ndert, ohne, dass das die beabsichtigte Operation war.</p> <pre><code>int a = 5;\nint b = a++; // Hauptoperation: b = 5      Nebeneffekt: a++\n</code></pre> <p>Hier ist die Hauptoperation die Aktion <code>b = a</code>. Der Nebeneffekt besteht darin, dass in der zweiten Zeile die Variable <code>a</code> um 1 erh\u00f6ht wird.</p>"},{"location":"2023%20SS/01%20Programmierparadigmen/Programmierparadigmen/","title":"Programmierparadigmen","text":"<p>Zu den am weitesten verbreiteten Programmierparadigmen geh\u00f6rt die Imperative Programmierung und die Funktionale Programmierung.</p> <p>Alle Programmiersprachen der Vorlesung sind objektorientiert und werden deshalb normalerweise der imperativen Programmierung zugeordnet.</p>"},{"location":"2023%20SS/02%20Zeiger/Paging/","title":"Paging","text":"<p>Im Normalfall werden alle Ressourcen, die ein Programm im #Stack oder im #Heap speichert, physikalisch im Arbeitsspeicher (RAM) angelegt.</p> <p>Die Gr\u00f6\u00dfe an Daten, die ein Rechner in seinem Arbeitsspeicher haben kann, ist physikalisch eingeschr\u00e4nkt. Wenn auf einem Rechner mehrere Programme gleichzeitig laufen, kann es sein, dass sie gemeinsam die Gr\u00f6\u00dfe des RAMs \u00fcberschreiten w\u00fcrden.</p> <p>Um den Arbeitsspeicher nicht zu \u00fcberlasten, kommt das sogenannte Paging zum Einsatz: Der reservierte Speicher (\"Page\") von Programmen, die an einem gewissen Punkt keine Rechenleistung verbrauchen, wird vom RAM auf die Festplatte verschoben. Der RAM wird immer f\u00fcr die Programme verwendet, die im Moment viel Rechenleistung ben\u00f6tigen.</p> <p>Wenn ein inaktives Programm jetzt wieder auf seine Daten zugreifen will, muss die Page des Programms wieder zur\u00fcck in den Arbeitsspeicher geladen werden. Das Verschieben von Daten zwischen RAM und Festplatte nennt man Paging.</p>"},{"location":"2023%20SS/02%20Zeiger/Paging/#virtueller-adressraum","title":"Virtueller Adressraum","text":"<p>Es ist auch gut zu wissen, dass das Programm selbst nichts von dem Verschieben seiner Daten mitbekommt. F\u00fcr das Programm bleiben die Speicheradressen seiner Variablen immer gleich, egal ob sie sich gerade auf dem RAM oder auf der Festplatte befinden. Die eigentlichen physischen Adressen sind also unabh\u00e4ngig von den Adressen, die innerhalb eines Programms genutzt werden. Deshalb spricht man bei den Speicheradressen, die ein einzelnes Programm reservieren kann, auch von seinem virtuellen Adressraum.</p>"},{"location":"2023%20SS/02%20Zeiger/Speicherverwaltung/","title":"Speicherverwaltung","text":"<p>Daten eines ausgef\u00fchrten Programms werden an unterschiedlichen Orten im Rechner gespeichert.</p> <p>Bei der Ausf\u00fchrung eines Programms liegen an einem festen Ort: - (Maschinen-)Code des Programms - Statische Variablen und Konstanten</p>"},{"location":"2023%20SS/02%20Zeiger/Speicherverwaltung/#stack","title":"Stack","text":"<p>Der Stack eines Programms wird bei der Ausf\u00fchrung dynamisch verwaltet. Das hei\u00dft, die Gr\u00f6\u00dfe des Stacks ver\u00e4ndert sich w\u00e4hrend des Programmablaufs.</p> <p>Wenn innerhalb einer Methode Variablen definiert werden, wird Speicher auf dem Stack reserviert (der Speicher w\u00e4chst). Sobald die Methode durchlaufen ist, werden die reservierten Speicheradressen wieder freigegeben (der Speicher nimmt ab).</p> <p>Der Stack wird f\u00fcr lokale Variablen genutzt, die z.B. nur innerhalb einer for-Schleife verwendet werden.</p> <p>[!NOTE] Wertsemantik Primitve Datentypen wie zum Beispiel <code>int</code> oder <code>float</code> werden normalerweise auf dem Stack gespeichert und als Wert behandelt: Wenn eine Methode einen Wert als Parameter annimmt, wird eine Kopie des Werts in der Methode verwendet.</p> <p>Der Wert kann also innerhalb der Methode ver\u00e4ndert werden, ohne das er sich au\u00dferhalb der Methode \u00e4ndert.</p>"},{"location":"2023%20SS/02%20Zeiger/Speicherverwaltung/#heap","title":"Heap","text":"<p>Der Heap wird von allen Programmen des Rechners gleichzeitig genutzt. Durch das \"Allokieren\" kann Speicher auf dem Heap f\u00fcr das eigene Programm reserviert werden.</p> <p>[!NOTE] Referenzsemantik Erweiterte Datentypen wie zum Beispiel ein Array oder ein Objekt werden normalerweise auf dem Heap angelegt und mit einem Zeiger als Referenz behandelt: Wenn eine Methode einen Zeiger als Parameter annimmt, wird kann dieser dereferenziert werden.</p> <p>Auf diese Weise wird ein Array oder Objekt global - also auch au\u00dferhalb der Methode - ver\u00e4ndert.</p>"},{"location":"2023%20SS/02%20Zeiger/Zeichenketten%20in%20C/","title":"Zeichenketten in C","text":"<p>In C k\u00f6nnen Zeichenketten (Strings) mit dem Typ <code>char*</code> definiert werden. Es handelt sich bei <code>char*</code> um einen Zeiger auf das erste Zeichen eines Strings.</p> <pre><code>char *adresse = \"Hello World!\";\n\nchar zeichen1 = *adresse;       // H\nchar zeichen2 = *(adresse + 1); // e\nchar zeichen3 = *(adresse + 2); // l\n</code></pre> <p>Die Variable <code>adresse</code> ist in diesem Beispiel eine Referenz auf den ersten Buchstaben \"H\".</p> <pre><code>*adresse\n\nH e l l o   W o r l d !\n^\n</code></pre> <p>Die einzelnen Zeichen des Strings <code>\"Hello World\"</code> k\u00f6nnen durch Dereferenzierung der Speicheradresse erhalten werden. Im Speicher liegen die Zeichen eines Strings direkt nebeneinander.</p> <p>Durch Addition kann deshalb mit <code>adresse + 2</code> zum Beispiel der dritte Buchstabe des Strings erhalten werden.</p> <pre><code>*(adresse + 2)\n\nH e l l o   W o r l d !\n    ^\n</code></pre>"},{"location":"2023%20SS/02%20Zeiger/Zeichenketten%20in%20C/#lange-eines-strings","title":"L\u00e4nge eines Strings","text":"<p>Da nur die Speicheradresse des ersten Zeichens von einem String gespeichert wird, ist nicht offensichtlich, welche L\u00e4nge ein String tats\u00e4chlich hat.</p> <p>Dieses Problem wird gel\u00f6st, indem die letzte Speicheradresse eines Strings mit dem speziellen Zeichen <code>\\0</code> markiert wird. Das Symbol bedeutet, das hier das Ende des Strings erreicht ist.</p> <pre><code>H e l l o   W o r l d ! \\0\n                         ^\n</code></pre>"},{"location":"2023%20SS/02%20Zeiger/Zeiger/","title":"Zeiger","text":"<p>Alle Variablen eines Programms m\u00fcssen an einem bestimmten Ort im Rechner gelagert werden. Jedes Mal, wenn im Ablauf eines Programms eine neue Variable deklariert wird, wird Speicher reserviert.</p> <pre><code>int a = 5;\nint b = 10;\n</code></pre> <p>Hier werden zwei Integer definiert. F\u00fcr beide Variablen werden im Speicher neue Adressen extra f\u00fcr die jeweiligen Integer reserviert. Es gibt jetzt also einen festen Ort im Speicher, an dem die Werte 5 und 10 eingetragen sind.</p> <p>Die Werte, die an diesen Speicheradressen eingetragen sind, k\u00f6nnen durch Zuweisungen ver\u00e4ndert werden.</p> <pre><code>int a = 5;\nint b = 10;\n\na = 7;\nb = a + 1;\n</code></pre> <p>Nach Ablauf des Codes stehen im Speicher an den jeweiligen Adressen von <code>a</code> und <code>b</code> jetzt die Zahlen 7 und 8. Die vorherigen Werte werden also durch die Zuweisungen \u00fcberschrieben. Es muss hier kein weiterer Speicher reserviert werden, weil keine neue Variable angelegt wird.</p>"},{"location":"2023%20SS/02%20Zeiger/Zeiger/#referenzierung","title":"Referenzierung","text":"<p>In C/C++ ist es m\u00f6glich herauszufinden, an welcher Speicheradresse der Wert einer Variable gespeichert ist.</p> <p>Ein Zeiger oder Pointer ist eine Speicheradresse. Zeiger sind keine Daten - stattdessen geben sie an, wo Programmdaten im Speicher zu finden sind. Mit anderen Worten, ein Zeiger ist eine Referenz auf Daten.</p> <pre><code>int a = 5;\n\nint* a_speicher_adresse = &amp;a; // REFERENZIERUNG\n</code></pre> <p>Der Ausdruck <code>&amp;a</code> bedeutet \"Speicheradresse von <code>a</code>\". An genau dieser Adresse liegt im Speicher jetzt die Zahl 5.</p> <p>Man sagt hier, dass <code>a_speicher_adresse</code> ein Pointer auf <code>a</code> oder eine Referenz auf <code>a</code> ist und auf den Integerwert 5 \"zeigt\".</p> <p>Durch das Symbol <code>*</code> nach dem Typ <code>int</code> wird angegeben, dass es sich um einen Zeiger auf einen Integer handelt.</p>"},{"location":"2023%20SS/02%20Zeiger/Zeiger/#dereferenzierung","title":"Dereferenzierung","text":"<p>Umgekehrt ist es auch m\u00f6glich, aus einer gegebenen Speicheradresse die darin gelagerten Daten zu lesen. Diesen Vorgang nennt man Dereferenzierung.</p> <pre><code>int a = 5;\n\nint* a_speicher_adresse = &amp;a; // REFERENZIERUNG\n\nint b = *a_speicher_adresse; // DEREFERENZIERUNG\n</code></pre> <p>Der Ausdruck <code>*a_speicher_adresse</code> bedeutet \"Gespeicherter Wert von <code>a_speicher_adresse</code>\".</p> <p>Hier wird die Referenz auf <code>a</code> wieder aufgel\u00f6st, sodass die neue Variable <code>b</code> schlie\u00dflich auch genau den Wert 5 hat, welcher an der Speicheradresse von <code>a</code> gespeichert war.</p>"},{"location":"2023%20SS/02%20Zeiger/Zeiger/#verkettete-listen","title":"Verkettete Listen","text":"<p>Verkettete Listen werden in C/C++ mit Zeigern umgesetzt: - Eine Liste besteht nur aus einem Zeiger auf das erste Element (Head) der Liste. - In jedem Element ist ein <code>*next</code> Zeiger auf das n\u00e4chste Element der Liste. - Auf diese Weise sind alle Elemente vom Anfang bis zum Ende der Liste miteinander verkettet.</p>"},{"location":"2023%20SS/03%20Objektorientierung/Datentypen/","title":"Datentypen","text":""},{"location":"2023%20SS/03%20Objektorientierung/Datentypen/#einfache-datentypen","title":"Einfache Datentypen","text":"<p>Einfache, eingebaute oder primitive Typen sind Datentypen, die in allen Programmiersprachen der Vorlesung vordefiniert sind. Dazu geh\u00f6ren unter anderem die Typen <code>int</code>, <code>float</code>, <code>boolean</code> und <code>char</code>.</p> <p>Einfache Datentypen haben bestimmte Wertebereiche. Zum Beispiel kann eine Variable vom Typen <code>int</code> in Java einen Zahlenwert zwischen \\(-2^{31}\\) und \\(2^{31}\\) haben. In manchen Sprachen (C++, Python) ist der Wertebereich plattformabh\u00e4ngig.</p>"},{"location":"2023%20SS/03%20Objektorientierung/Datentypen/#hullenklasse-java","title":"H\u00fcllenklasse (Java)","text":"<p>In Java gibt es zu primitiven Datentypen die jeweiligen \"H\u00fcllenklassen\" <code>Integer</code>, <code>Float</code> und <code>Boolean</code>.</p> <p>Diese H\u00fcllenklassen besitzen 1. Konstanten des Datentyp-Wertebereichs (z.B. <code>Integer.MIN_VALUE</code>, <code>Integer.MAX_VALUE</code>) 2. statische Methoden zum Konvertieren von einem String in den jeweiligen Datentyp (z.B. <code>Integer.parseInt(...)</code>).</p>"},{"location":"2023%20SS/03%20Objektorientierung/Datentypen/#abstrakte-datentypen","title":"Abstrakte Datentypen","text":"<p>Ein abstrakter Datentyp ist in den Programmiersprachen der Vorlesung durch Klassen umgesetzt.</p> <p>Abstrakte Datentypen (Klassen) k\u00f6nnen Attribute, Konstruktoren und Methoden beinhalten. Sie dienen als Vorlage f\u00fcr abstrakte Datenstrukturen.</p> <p>Abstrakte Datenstrukturen sind einzelne Objekte oder Instanzen von abstrakten Datentypen. Sie besitzen Kopien der Methoden und Attribute, die in der Klasse definiert sind.</p>"},{"location":"2023%20SS/03%20Objektorientierung/Einleitung/","title":"Einleitung","text":"<p>In diesem Kapitel geht es haupts\u00e4chlich darum, die Gemeinsamkeiten von objektorientierten Programmiersprachen zu kennen. Es wird nicht verlangt, die Konzepte in allen Programmiersprachen der Vorlesung auswendig zu lernen und implementieren zu k\u00f6nnen. Stattdessen wird versucht darzustellen, dass diese Konzepte sprachen\u00fcbergreifend sind und nicht nur in Java existieren.</p> <p>Zu den Themen des Kapitels \"Objektorientierung\" geh\u00f6ren Datentypen, das damit verkn\u00fcpfte Prinzip von Klassen und Objekten und die Polymorphie.</p>"},{"location":"2023%20SS/03%20Objektorientierung/Klassen%20und%20Objekte/","title":"Klassen und Objekte","text":""},{"location":"2023%20SS/03%20Objektorientierung/Klassen%20und%20Objekte/#klassenbeziehungen","title":"Klassenbeziehungen","text":"<p>Die wichtigsten Beziehungen zwischen zwei Klassen sind 1. Die Benutzungs-Beziehung - In jeder Klasse stehen Methoden, die von anderen Klassen verwendet werden k\u00f6nnen. 2. Die Vererbungs-Beziehung - Jede Klasse kann als Oberklasse f\u00fcr ihre erbenden Unterklassen dienen.</p>"},{"location":"2023%20SS/03%20Objektorientierung/Klassen%20und%20Objekte/#klassendaten-und-operationen","title":"Klassendaten und -operationen","text":"<p>Klassendaten sind Attribute, die nicht einem Objekt, sondern einer ganzen Klasse geh\u00f6ren. In den Sprachen C++, C# und Java sind Klassendaten mit <code>static</code> gekennzeichnet.</p> <p>Zus\u00e4tzlich spricht man von Klassenoperationen, wenn eine Klasse statische Methoden enth\u00e4lt.</p> <p>Beispiel in Java: <pre><code>public class Circle {\nprivate static final float PI = 3.14159; // Statisches Klassenattribut\n\n// ...\n\npublic static float getPI() { // Statische Klassenoperation\nreturn Circle.PI;\n}\n}\n</code></pre></p>"},{"location":"2023%20SS/03%20Objektorientierung/Klassen%20und%20Objekte/#abstrakte-klassen","title":"Abstrakte Klassen","text":"<p>Von abstrakten Klassen k\u00f6nnen keine Objekte erzeugt werden. Sie dienen sozusagen nur als Gruppierung oder Vorlage f\u00fcr spezifischere Unterklassen.</p>"},{"location":"2023%20SS/03%20Objektorientierung/Kompilationseinheiten/","title":"Kompilationseinheiten","text":"<p>Ein Programmierprojekt besteht meist aus mehreren selbstgeschriebenen und importierten Quellcode-Dateien, die alle gemeinsam in Maschinencode \u00fcbersetzt werden m\u00fcssen, um das Programm auszuf\u00fchren.</p> <p>In Java kann man durch die Nutzung von <code>import</code> Klassen aus anderen Dateien verwenden, zum Beispiel die Standardimplementierung einer <code>ArrayList</code>:</p> <pre><code>import java.util.ArrayList;\n</code></pre> <p>Diese Zeile ist wichtig f\u00fcr den Compiler, damit er wei\u00df, welche Dateien alle f\u00fcr das Programm relevant sind. W\u00e4hrend dem Kompilieren werden alle relevanten Klassendateien \u00fcbersetzt, sodass man ausf\u00fchrbaren Code erh\u00e4lt.</p>"},{"location":"2023%20SS/03%20Objektorientierung/Kompilationseinheiten/#code-aufteilung-in-cc","title":"Code-Aufteilung in C/C++","text":"<p>In den Programmiersprachen C/C++ ist dieses Konzept noch etwas verfeinert: Zu jeder Klasse gibt es klar getrennt eine Schnittstellendatei und eine Implementationsdatei.</p> <p>In der Header-/Schnittstellendatei (Dateiendung <code>.h</code> oder <code>.hpp</code>) stehen nur die Signaturen von Methoden und Konstruktoren der Klasse. Diese Datei wird vom Compiler verwendet, um generell zu wissen, welche Klassen und Methoden in verschiedenen Projektdateien existieren.</p> <p>Die Implementationsdatei (Dateiendung <code>.c</code>, <code>.cc</code> oder <code>.cpp</code>) definiert den \"Body\" oder die Implementierung der einzelnen Methoden, die in der zugeh\u00f6rigen Headerdatei stehen.</p> <p>Eine Projektstruktur kann dann zum Beispiel so aussehen: <pre><code>projektordner/\n- circle.hpp\n- circle.cpp\n</code></pre></p> <pre><code>// circle.hpp\n\nclass Circle\n{\nfloat x;\nfloat y;\nfloat radius;\n\npublic:\nCircle(float x, float y, float radius);\nfloat getArea();\n};\n</code></pre> <pre><code>// circle.cpp\n\n#include \"circle.h\"\n\nCircle::Circle(float x, float y, float radius)\n{\nthis.x = x;\nthis.y = y;\nthis.radius = radius;\n}\n\nfloat Circle::getArea()\n{\nfloat PI = 3.14159;\nreturn PI * radius * radius;\n}\n</code></pre>"},{"location":"2023%20SS/03%20Objektorientierung/Polymorphie/","title":"Polymorphie","text":"<p>Polymorphie (\"Vielgestaltigkeit\") hei\u00dft bei objektorientierten Sprachen, dass ein Objekt mehr als nur einer festen Klasse angeh\u00f6ren kann. Durch Vererbung ist es m\u00f6glich, ein Objekt zu verallgemeinern oder zu spezifizieren.</p> <p>Wenn man zum Beispiel einen Hund oder eine Katze betrachtet, k\u00f6nnen beide auch als Haustier oder noch weiter als Tier und Lebewesen verallgemeinert werden.</p> <pre><code>            Lebewesen\n                |\n               Tier\n                |\n             Haustier\n        ________|________\n        |               |\n      Katze            Hund\n</code></pre> <p>Eine Katze wird kann in dieser Klassenhierarchie polymorph genannt werden. Sie kann in mehreren Formen oder Gestalten beschrieben werden: Als Lebewesen, als Tier, als Haustier oder am pr\u00e4zisesten als Katze.</p>"},{"location":"2023%20SS/03%20Objektorientierung/Polymorphie/#vererbung","title":"Vererbung","text":"<p>Angenommen, in der Klasse Haustier steht ein <code>name</code>-Attribut und in der Klasse Lebewesen gibt es ein <code>alter</code>-Attribut. Dann werden diese Attribute an die Klassen Katze und Hund vererbt, sodass jede Katze und jeder Hund jeweils ein eigenes Alter und einen bestimmten Namen hat.</p> <pre><code>              Lebewesen - - - - - - [alter] (int)\n                  |\n                 Tier\n                  |\n               Haustier - - - - - - [name] (String)\n        __________|__________\n        |                   |\n      Katze                Hund\n    /       \\            /      \\\n [alter]  [name]      [alter] [name]\n</code></pre> <p>Die Vererbung und die Polymorphie sind in der objektorientierten Programmierung ein allgegenw\u00e4rtiges Konzept.</p> <p>Durch die Polymorphie kann man z.B. in der Programmiersprache Java ein Objekt der Klasse Katze erstellen und als eine andere \"Gestalt\" behandeln. In diesem Beispiel wird eine Katze als allgemeines Lebewesen behandelt. Deshalb kann hier nicht das <code>name</code>-Attribut der spezifischeren Klasse Haustier verwendet werden.</p> <pre><code>Lebewesen lebewesen = new Katze(2, \"Mark\");\n\nint alter = lebewesen.alter;  //  \u2714 Keine Fehler\n\nString name = lebewesen.name; // \u274c Fehler, weil nicht jedes LEBEWESEN einen Namen hat\n^^^^\n</code></pre>"},{"location":"2023%20SS/04%20Spezifikation%20durch%20Vertrag/Assertions/","title":"Assertions","text":"<p>Assertions (auch \"Annahmen\" und \"Zusicherungen\" genannt) k\u00f6nnen im Quellcode geschrieben werden, um sicherzustellen, dass das Programm zu einem gewissen Zeitpunkt (z.B. beim Aufrufen einer Methode) in einem erwarteten Zustand ist.</p> <p>In Java geht das beispielsweise mit einer <code>assert</code>-Zeile:</p> <pre><code>public static float getAverageOfArray(float[] array) {\nassert array != null: \"The array parameter must not be null.\";\nassert array.length &gt; 0: \"The array parameter must not be empty.\";\n\n// ...\n}\n</code></pre> <p>Hier wird zugesichert (\"asserted\"), dass beim Start der Methode der \u00fcbergebene Array-Parameter <code>array</code> nicht <code>null</code> ist und mindestens ein Element enth\u00e4lt (L\u00e4nge &gt; 0). Jedes Mal, wenn die Methode aufgerufen wird, werden diese Bedingungen (<code>array != null</code> und <code>array.length &gt; 0</code>) \u00fcberpr\u00fcft. Falls man der Methode einen leeren Array \u00fcberliefert, wird das Programm an dieser Stelle durch eine Exception abgebrochen.</p> <p>Es ist m\u00f6glich, beim Ausf\u00fchren eines Java-Programms \u00fcber die Kommandozeile die Assertions an- oder auszuschalten. Durch ein Argument namens <code>-enableassertions</code> wird entschieden, ob das Programm bei fehlgeschlagenen Assertion-Bedingungen abbricht oder nicht.</p>"},{"location":"2023%20SS/04%20Spezifikation%20durch%20Vertrag/Begrifflichkeiten/","title":"Begrifflichkeiten","text":"<p>In dem Konzept Spezifikation durch Vertrag k\u00f6nnen verschiedene Bedingungen festgelegt werden, die im \"Vertrag\" eines Dienstes beachtet werden m\u00fcssen.</p>"},{"location":"2023%20SS/04%20Spezifikation%20durch%20Vertrag/Begrifflichkeiten/#vorbedingung","title":"Vorbedingung","text":"<p>Eine Vorbedingung beschreibt, was vor dem Aufrufen einer Methode oder eines Dienstes gelten muss. Um zum Beispiel die Quadratwurzel einer Zahl zu berechnen, muss vorher gelten, dass die Zahl nicht negativ ist. Der eingegebene Parameter hat also einen festgelegten Wertebereich zwischen 0 und \\(\\infty\\).</p>"},{"location":"2023%20SS/04%20Spezifikation%20durch%20Vertrag/Begrifflichkeiten/#nachbedingung","title":"Nachbedingung","text":"<p>Nachdem ein Dienst fertig bearbeitet ist, wird sein Ergebnis zur\u00fcckgeliefert. F\u00fcr dieses Ergebnis stehen in der Spezifikation immer eine oder mehrere Nachbedingungen. Sie bestimmen, was zur\u00fcckgegeben wird - den R\u00fcckgabetyp und den Wertebereich des Ergebnisses.</p>"},{"location":"2023%20SS/04%20Spezifikation%20durch%20Vertrag/Begrifflichkeiten/#invariante","title":"Invariante","text":"<p>Mit einer Invariante in einem Vertrag wird festgelegt, dass sich bestimmte Zust\u00e4nde einer Software w\u00e4hrend des Aufrufen eines Dienstes nicht \u00e4ndern und konsistent bleiben. Falls zum Beispiel eine Methode <code>arrayToString</code> die Elemente eines Arrays in einem String zur\u00fcckgeben soll, kann in der Spezifikation dieser Methode die folgende Invariante stehen: - \"Die L\u00e4nge und der Inhalt des \u00fcberlieferten Arrays wird durch den Dienst <code>arrayToString</code> nicht ver\u00e4ndert.\"</p> <pre><code>public static String arrayToString(int[] array) {\nreturn // ...\n}\n</code></pre>"},{"location":"2023%20SS/04%20Spezifikation%20durch%20Vertrag/Spezifikation%20durch%20Vertrag/","title":"Spezifikation durch Vertrag","text":"<p>Spezifikation durch Vertrag (SdV) f\u00fchrt zu besserer Softwarequalit\u00e4t.</p> <p>Eine Spezifikation dient als Vorlage f\u00fcr den Code, der in einem Programm stehen soll. In der Spezifikation ist klar beschrieben, welche Werte in eine Methode eingegeben und von ihr ausgegeben werden k\u00f6nnen. Das hei\u00dft, dass es neben dem Quellcode noch ein Dokument gibt, in dem die Anforderungen an einzelne Komponenten (Methoden, Getter, Setter) einer Software beschrieben werden.</p>"},{"location":"2023%20SS/04%20Spezifikation%20durch%20Vertrag/Spezifikation%20durch%20Vertrag/#client-supplier-modell","title":"Client-Supplier-Modell","text":"<p>In dem Client-Supplier-Modell werden die einzelnen Methoden (und weiteren Komponenten) eines Programms als Supplier betrachtet. Sie bieten einen Dienst an, der an anderen Stellen des Codes genutzt werden kann.</p> <p>Wenn zum Beispiel eine <code>sqrt(x)</code> Methode zum Berechnen der Quadratwurzel existiert, kann diese als ein Dienst-Angebot beschrieben werden. Es wird angeboten, die Quadratwurzel von einer Zahl <code>x</code> zu berechnen. </p> <pre><code>public static float sqrt(float x) {\n/// ...\n}\n</code></pre> <p>F\u00fcr dieses Angebot kann es vertragliche Bedingungen geben: es ist beispielsweise notwendig, dass die eingegebene Zahl <code>x</code> \\(\\geq 0\\) ist. Gleichzeitig kann auch garantiert werden, dass die ausgegebene Zahl <code>sqrt(x)</code> \\(\\geq 0\\) ist.</p> <p>Angenommen, es gibt noch eine weitere Methode in dem Programm: <code>distance(px, py, qx, qy)</code>. In dieser Methode wird die Distanz zwischen zwei Punkten \\((px, py)\\) und \\((qx, qy)\\) berechnet.</p> <p>[!example] Mathematische Notation In mathematischer Schreibweise l\u00e4sst sich die Distanzberechnung wie folgt formulieren. \\(\\(Distanz = \\sqrt{(qx-px)^2 + (qy-py)^2}\\)\\)</p> <pre><code>public static float distance(float px, float py, float qx, float qy) {\nfloat x = qx - px;\nfloat y = qy - py;\n\nreturn sqrt( x*x + y*y );\n}\n</code></pre> <p>Es wird die oben beschriebene Methode <code>sqrt(x)</code> aufgerufen und als Dienst verwendet. Es gibt also zwei Seiten:</p> <ol> <li>Der Kunde (Client) - Die <code>distance</code>-Methode will den Dienst <code>sqrt</code> benutzen.</li> <li>Der Anbieter (Supplier) - Die <code>sqrt</code>-Methode bietet ihren Dienst an.</li> </ol> <p>Um den Dienst nutzen zu k\u00f6nnen, muss ein \"Vertrag\" geschlossen werden. Sowohl der Supplier als auch der Client sollen den Vertrag einhalten und alle Bedingungen erf\u00fcllen. Welche Bedingungen das sind, steht jeweils in der Spezifikation der Software. In diesem Fall gibt es zwei Bedingungen:</p> <ol> <li>Eine Vorbedingung - Die eingegebene Zahl <code>x</code> in <code>sqrt(x)</code> darf nicht negativ sein.</li> <li>Eine Nachbedingung - Das Ergebnis von <code>sqrt(x)</code> ist die Quadratwurzel von <code>x</code>. Dieses Ergebnis kann nicht negativ sein.</li> </ol> <p>Es ist durch den Vertrag klar definiert, was die <code>sqrt</code>-Methode ben\u00f6tigt, um ein gew\u00fcnschtes Ergebnis zu liefern. Ein Client wei\u00df deshalb immer genau, welches Ergebnis er von seinem Supplier bekommen wird, wenn der Vertrag korrekt eingehalten wird.</p> <p>Mit Spezifikation durch Vertrag werden instabile Programmzust\u00e4nde (wie Nebeneffekte) schon vor dem Schreiben des Quellcodes gezielt vermieden - die Softwarequalit\u00e4t verbessert sich also enorm.</p>"},{"location":"2023%20SS/05%20Rekursiv%20und%20Iterativ/Euklidischer%20Algorithmus/","title":"Euklidischer Algorithmus","text":"<p>Betrachtet man die Zahlen 44 und 12, dann sieht man, dass sie beide durch 2 teilbar sind. 2 ist also ein gemeinsamer Teiler der beiden Zahlen. Ein weiterer gemeinsamer Teiler ist die Zahl 4, da sowohl die Division \\(44 : 4 = 11\\) als auch \\(12 : 4 = 3\\) eine Ganzzahl ergibt.</p> <p>Der Euklidische Algorithmus berechnet den gr\u00f6\u00dften gemeinsamen Teiler (\"ggT\") von zwei Zahlen \\(a\\) und \\(b\\). Der gr\u00f6\u00dfte gemeinsame Teiler ist die h\u00f6chste Zahl, durch die sowohl \\(a\\) als auch \\(b\\) geteilt werden kann.</p> <p>In der folgenden Abbildung wird veranschaulicht, wie der Algorithmus funktioniert. In jedem Schritt wird die kleinere Zahl so oft wie m\u00f6glich von der gr\u00f6\u00dferen Zahl subtrahiert. Das wird so oft wiederholt, bis die kleinere von beiden Zahlen komplett von der anderen subtrahiert werden kann und das Ergebnis der Subtraktion 0 ist. Ab diesem Fall ist der Algorithmus fertig und die verbleibende Zahl wird zur\u00fcckgegeben.</p> <p></p>"},{"location":"2023%20SS/05%20Rekursiv%20und%20Iterativ/Rekursiv%20und%20Iterativ/","title":"Rekursiv und Iterativ","text":"<p>Ein Algorithmus kann rekursiv oder iterativ geschrieben werden. Als Beispiel-Algorithmus wird in der Vorlesung der Euklidische Algorithmus erkl\u00e4rt und in sowohl rekursiver als auch iterativer Form dargestellt.</p>"},{"location":"2023%20SS/05%20Rekursiv%20und%20Iterativ/Rekursiv%20und%20Iterativ/#iterativ","title":"Iterativ","text":"<p>Ein iterativer Algorithmus nutzt eine Schleife (z.B. <code>while</code>-Schleife oder <code>for</code>-Schleife), um zu einer L\u00f6sung zu kommen. Es gibt in einer Schleife immer eine Abbruchbedingung, die daf\u00fcr sorgt, dass die Schleife nicht unendlich weiterl\u00e4uft.</p> <p>Da es sich bei Schleifen um ein zustandsorientiertes, nicht-funktionales Konzept handelt, ist dieser Ansatz nur in der imperativen Programmierung umsetzbar.</p> <p>Der Euklidische Algorithmus l\u00e4sst sich iterativ auf die folgende Weise implementieren.</p> <pre><code>def ggT(a, b):\n    while a != 0: # GEGENTEIL der Abbruchbedingung\n\n        if a &gt; b:\n            a = a - b\n        else:\n            # (Die Variablen werden miteinander vertauscht, damit die\n            # Abbruchbedingung funktioniert)\n            previous_a = a\n\n            a = b - a\n            b = previous_a\n\n    return b\n</code></pre>"},{"location":"2023%20SS/05%20Rekursiv%20und%20Iterativ/Rekursiv%20und%20Iterativ/#rekursiv","title":"Rekursiv","text":"<p>Der rekursive Ansatz eines Algorithmus besteht aus einer Methode, die sich selbst aufruft. Auch in jeder rekursiven Methode muss es eine Abbruchbedingung geben, damit jene nicht unendlich lang weitere Aufrufe t\u00e4tigt. Erst, sobald die Abbruchbedingung erf\u00fcllt ist, wird ein Wert zur\u00fcckgegeben.</p> <p>In der funktionalen Programmierung ist ausschlie\u00dflich die rekursive Umsetzung eines Algorithmus m\u00f6glich, da hier keine Programmzust\u00e4nde zugewiesen werden m\u00fcssen.</p> <p>Der Euklidische Algorithmus l\u00e4sst sich rekursiv auf die folgende Weise implementieren.</p> <pre><code>def ggT(a, b):\n    if a == 0: # Abbruchbedingung\n        return b\n    else:\n        if a &gt; b:\n            return ggT(a - b, b) # Rekursiv: die Methode \"ggT\" ruft sich selbst auf.\n        else:\n            return ggT(b - a, a)\n</code></pre> <p>Hier wird solange die kleinere Zahl von der gr\u00f6\u00dferen subtrahiert, bis die Zahl 0 erreicht ist. Als Abbruchbedingung dient hier die obere Zeile <code>if a == 0</code>. Im folgenden Block werden alle Aufrufe dargestellt, die durch die urspr\u00fcngliche Methode <code>ggT(44, 12)</code> rekursiv entstehen.</p> <pre><code>ggT(      44, 12) # a &gt; b\n ggT(     32, 12) # a &gt; b\n  ggT(    20, 12) # a &gt; b\n   ggT(    8, 12) # b \u2264 a\n    ggT(   4,  8) # b \u2264 a\n     ggT(  4,  4) # b \u2264 a\n      ggT( 0,  4) # a == 0 (Abbruchbedingung ist erf\u00fcllt)\n       return 4\n</code></pre>"},{"location":"2023%20SS/05%20Rekursiv%20und%20Iterativ/Rekursiv%20und%20Iterativ/#endrekursiv","title":"Endrekursiv","text":"<p>Eine rekursive Methode wird endrekursiv genannt, wenn die Methode direkt nach dem rekursiven Selbstaufruf an ihrem Ende angelangt ist und danach kein Code mehr in der Methode ausgef\u00fchrt werden muss.</p> <pre><code>def f(x):\n    if x == 0:\n        return 0\n\n    f(x - 1) # Rekursiv: die Methode \"f\" ruft sich selbst auf.\n\n    # NICHT ENDREKURSIV: die Methode f\u00fchrt weiteren Code\n    # nach dem rekursiven Aufruf aus.\n    print(x)\n\n\ndef g(x):\n    if x == 0:\n        return 0\n\n    # ENDREKURSIV: die Methode \"g\" ruft sich selbst auf und\n    # ist danach am Ende angelangt.\n    return g(x - 1)\n</code></pre>"},{"location":"2023%20SS/05%20Rekursiv%20und%20Iterativ/Rekursiv%20und%20Iterativ/#umwandlung-von-rekursiv-zu-iterativ","title":"Umwandlung von Rekursiv zu Iterativ","text":"<p>Jeder endrekursiv formulierte Algorithmus kann auch iterativ formuliert werden. Daf\u00fcr muss man verstehen, wo in dem gegebenen endrekursiven Algorithmus die folgenden 3 Dinge stehen:</p> <ol> <li>Das Abbruchkriterium</li> <li>Die R\u00fcckgabe beim Abbruch</li> <li>Die Aktion eines Rekursionsaufrufs</li> </ol> <pre><code>def ggT(a, b):\n    if a == 0: # ABBRUCHKRITERIUM / Abbruchbedingung\n        return b # R\u00dcCKGABE BEIM ABBRUCH\n    else:\n        if a &gt; b:\n            return ggT(a - b, b) # REKURSIONSAUFRUF 1\n        else:\n            return ggT(b - a, a) # REKURSIONSAUFRUF 2\n</code></pre> <p>Diese Teile des Codes k\u00f6nnen dann in eine iterative Form mit einer <code>while</code>-Schleife umstrukturiert werden. Daf\u00fcr sind die folgenden Schritte n\u00f6tig:</p> <ol> <li>Das Gegenteil des Abbruchkriteriums wird als Bedingung f\u00fcr die <code>while</code>-Schleife verwendet.</li> <li>Die R\u00fcckgabe beim Abbruch wird hinter die <code>while</code>-Schleife gesetzt.</li> <li>Die Aktion eines Rekursionsaufrufs wird innerhalb der <code>while</code>-Schleife geschrieben.</li> </ol> <pre><code># SCHRITT 1\n\ndef ggT(a, b):\n    while a != 0: # GEGENTEIL DES ABBRUCHKRITERIUMS\n        ...\n</code></pre> <pre><code># SCHRITT 2\n\ndef ggT(a, b):\n    while a != 0:\n        ...\n\n    return b # R\u00dcCKGABE BEIM ABBRUCH\n</code></pre> <pre><code># SCHRITT 3\n\ndef ggT(a, b):\n    while a != 0:\n\n        if a &gt; b:\n            a = a - b # AKTION VON REKURSIONSAUFRUF 1\n\n        else:\n            # AKTION VON REKURSIONSAUFRUF 2\n\n            # (Die Variablen werden miteinander vertauscht, damit die\n            # Abbruchbedingung funktioniert)\n            previous_a = a\n\n            a = b - a\n            b = previous_a\n\n    return b\n</code></pre>"},{"location":"2023%20SS/06%20Generizit%C3%A4t/Generizit%C3%A4t/","title":"Generizit\u00e4t","text":"<p>Das objektorientierte Konzept der Generizit\u00e4t erlaubt es, den Typen einer Klasse anzugeben und innerhalb des Codes wiederzuverwenden. Zum Beispiel sagt eine generische Liste aus, dass alle Elemente der Liste von einem bestimmten Typ sind.</p> <p>In Java ist die Generizit\u00e4t mit sogenannten parametrisierten Typen umgesetzt. In spitzen Klammern <code>&lt;...&gt;</code> kann man nach einem Methodenname oder Klassenname einen spezifischen Typen angeben. Um das Konzept n\u00e4her zu erkl\u00e4ren, werden die Klassen und Vererbungen aus dem Kapitel Polymorphie wiederverwendet.</p> <pre><code>            Lebewesen\n                |\n               Tier\n                |\n             Haustier\n        ________|________\n        |               |\n      Katze            Hund\n</code></pre> <p>Jede Klasse in dem Schaubild kann als Typ genutzt werden. Eine generische Liste kann so definiert werden, dass sie z.B. nur Elemente vom Typ Hund enth\u00e4lt.</p> <pre><code>ArrayList&lt;Hund&gt; hunde = new ArrayList&lt;Hund&gt;();\n\nhunde.add(new Hund()); // Objekt vom Typ \"Hund\" kann hinzugef\u00fcgt werden\n\nhunde.add(new Katze()); // Objekt vom Typ \"Katze\" kann NICHT hinzugef\u00fcgt werden\n^^^^^\n</code></pre> <p>Weil eine Katze nicht von der Klasse Hund erbt, kann sie nicht in die generische Liste eingef\u00fcgt werden. Die Schreibweise <code>ArrayList&lt;Hund&gt;</code> funktioniert, weil die Klasse <code>ArrayList</code> generisch ist und einen parametrisierten Typ annimmt.</p> <p>Um eine Klassendefinition generisch zu machen, k\u00f6nnen Typ-Parameter mit einem Namen angegeben werden. Normalerweise ist dieser Name <code>T</code> (\"type\") oder im Falle von Kollektionsklassen <code>E</code> (\"element\").</p> <pre><code>public class MyList&lt;E&gt; { // &lt;E&gt; macht diese Klasse zu einer generischen Klasse\n\nprivate E[] elements; // Der Typ-Parameter E kann in der Klasse genutzt werden\n\npublic E get(int index) {\nreturn elements[index];\n}\n}\n</code></pre>"},{"location":"2023%20SS/06%20Generizit%C3%A4t/Generizit%C3%A4t/#generizitat-in-c","title":"Generizit\u00e4t in C++","text":"<p>In C++ k\u00f6nnen Klassen und Methoden auf die gleiche Weise umgesetzt werden, allerdings unterscheidet sich die Notation. Anstatt den Typ-Parameter in spitzen Klammern hinter den Klassennamen zu schreiben, wird <code>template &lt;typename ...&gt;</code> vor den Klassennamen geschrieben. \u00c4hnlich wie in Java kann auch hier eine beliebige Bezeichnung f\u00fcr den Typ-Parameter ausgesucht werden, normalerweise <code>T</code> oder f\u00fcr Listen- und Mengen-Datenstrukturen <code>E</code>.</p> <p>Die Definition der generischen Klasse <code>MyList</code> von oben sieht in C++ zum Beispiel folgenderma\u00dfen aus.</p> <pre><code>// \"template &lt;typename E&gt;\" macht diese Klasse zu einer generischen Klasse\ntemplate &lt;typename E&gt; class MyList {  private:\nE elements[]; // Der Typ-Parameter E kann in der Klasse genutzt werden\n\npublic:\nE get(int index) {\nreturn elements[index];\n}\n};\n</code></pre>"},{"location":"2023%20SS/06%20Generizit%C3%A4t/Generizit%C3%A4t/#eingeschrankte-generizitat","title":"Eingeschr\u00e4nkte Generizit\u00e4t","text":"<p>Wenn die Generizit\u00e4t einer Klasse oder einer Methode auf bestimmte Typen beschr\u00e4nkt wird, spricht man von eingeschr\u00e4nkter Generizit\u00e4t. Das ist n\u00fctzlich, wenn man die Attribute und Methoden einer bestimmten Klasse verwenden will.</p> <p>In Java wird daf\u00fcr die Notation <code>&lt;T extends ...&gt;</code> genutzt, wobei hinter dem Wort extends der eingeschr\u00e4nkte Typ geschrieben wird. Im folgenden Beispiel wird die generische Klasse <code>Tierbesitzer</code> auf den Typ-Parameter Haustier eingeschr\u00e4nkt.</p> <pre><code>public class Tierbesitzer&lt;T extends Haustier&gt; {\nprivate T haustier;\n\npublic Tierbesitzer(T haustier) {\nthis.haustier = haustier;\n}\n\npublic String getHaustierName() {\n// Die Methode \"getName()\" ist in der Klasse \"Haustier\" definiert und\n// kann hier wegen der Einschr\u00e4nkung &lt;T extends Haustier&gt; genutzt werden\nreturn haustier.getName();\n}\n}\n</code></pre> <p>Beim Erzeugen eines <code>Tierbesitzer</code>-Objekts kann als generischer Typ Haustier oder eine Unterklasse von Haustier angegeben werden.</p> <pre><code>Katze katze = new Katze();\n\nTierbesitzer&lt;Katze&gt; katzenBesitzer = new Tierbesitzer&lt;&gt;(katze); \u2714\n\nTierbesitzer&lt;Haustier&gt; haustierBesitzer = new Tierbesitzer&lt;&gt;(katze); \u2714\n\n\nTierbesitzer&lt;Lebewesen&gt; lebewesenBesitzer = new Tierbesitzer&lt;&gt;(katze);\n^^^^^^^^^\n// \u274c Der Typ \"Lebewesen\" kann NICHT als Typ-Parameter genutzt werden,\n//    da ein Lebewesen keine Unterklasse von \"Haustier\" ist.\n</code></pre> <p>Im Gegensatz zu Java gibt es in C++ keine eingeschr\u00e4nkte Generizit\u00e4t. Es ist also nicht m\u00f6glich, den Typ-Parameter einer Klasse oder einer Methode auf einen bestimmten Typen zu beschr\u00e4nken.</p>"},{"location":"2023%20SS/06%20Generizit%C3%A4t/Komponenten%20und%20Anwendungen/","title":"Komponenten und Anwendungen","text":"<p>Als Komponente wird ein Teil eines Programms bezeichnet, der ausschlie\u00dflich einen einzigen, spezifischen Zweck erf\u00fcllt. Die einzelnen Komponenten, die in einer Software existieren, sind \"abgeschlossene Systeme\", also unabh\u00e4ngig voneinander. In anderen Worten: die Implementierung einer Komponente hat keinen Einfluss auf die Implementierung der anderen Komponenten.</p> <p>[!example] Beispiel Zum Beispiel k\u00f6nnte es ein Programm geben, in dem es die zwei folgenden Komponenten gibt: 1. Zahlengenerator - erf\u00fcllt den Zweck, zuf\u00e4llige Zahlen zur\u00fcckzugeben. 2. Zahlensortierer - erf\u00fcllt den Zweck, eine Liste von Zahlen zu sortieren.</p> <p>Diese beiden Komponenten funktionieren unabh\u00e4ngig voneinander und erf\u00fcllen komplett unterschiedliche Zwecke.</p> <p>Allerdings k\u00f6nnen sie im Programm kombiniert werden, sodass beim Ausf\u00fchren des Programms erst ein paar zuf\u00e4llige Zahlen generiert werden (Komponente 1) und diese danach sortiert werden (Komponente 2).</p> <p>Die Aufteilung einer Software in mehrere Komponenten ist wichtig, um eine bessere \u00dcbersicht und eine bessere Softwarequalit\u00e4t zu erhalten.</p>"},{"location":"2023%20SS/06%20Generizit%C3%A4t/Komponenten%20und%20Anwendungen/#werkzeugkastenkomponente","title":"Werkzeugkastenkomponente","text":"<p>Eine Werkzeugkastenkomponente ist eine Komponente, die mehrere, eng verwandte Methoden zur Verf\u00fcgung stellt, die von anderen Teilen des Programms verwendet werden k\u00f6nnen. Wie aus einem Werkzeugkasten k\u00f6nnen die Methoden der Komponente dann als Hilfsmittel im Code angewandt werden. Eine Werkzeugkomponente kann zum Beispiel eine Klasse sein, in der mehrere verschiedene Sortieralgorithmen implementiert sind.</p> <pre><code>public class ToolsetSort {\npublic void bubbleSort(int[] array) {\n// ...\n}\n\npublic void quickSort(int[] array) {\n// ...\n}\n\npublic boolean isSorted(int[] array) {\n// ...\n}\n}\n</code></pre>"},{"location":"2023%20SS/06%20Generizit%C3%A4t/Komponenten%20und%20Anwendungen/#generische-komponenten","title":"Generische Komponenten","text":"<p>Mithilfe von Generizit\u00e4t ist es m\u00f6glich, einen Algorithmus f\u00fcr unterschiedliche Datentypen zu verwenden. So kann man zum Beispiel einen Sortieralgorithmus entwerfen, der nicht nur Integer, sondern auch Strings und andere Typen sortieren kann. Durch die Nutzung von Generizit\u00e4t muss man also nur eine einzige Implementierung des Algorithmus schreiben, die f\u00fcr alle m\u00f6glichen Datentypen funktioniert. Damit spart man nicht nur an Schreibarbeit, sondern erh\u00f6ht auch die Softwarequalit\u00e4t, weil der Algorithmus genau an einer bestimmten Stelle im Code zu finden ist.</p> <p>Sehr praktisch kann es sein, eine ganze Werkzeugkastenkomponente generisch zu machen. Auf diese Weise k\u00f6nnen alle darin enthaltenen Methoden auf den parametrisierten Typen eingeschr\u00e4nkt werden.</p> <p>Im folgenden Beispiel wurde die Sortier-Werkzeugkastenkomponente um einen  generischen Typ-Parameter <code>&lt;E extends Comparable&lt;E&gt;&gt;</code> erweitert. Die Algorithmen <code>bubbleSort</code>, <code>quickSort</code> und <code>isSorted</code> nutzen diesen Typen in ihrer Signatur und funktionieren jetzt also auf allen m\u00f6glichen vergleichbaren Datentypen (<code>Comparable</code>).</p> <pre><code>public class ToolsetSort&lt;E extends Comparable&lt;E&gt;&gt; {\npublic void bubbleSort(E[] array) {\n// ...\n}\n\npublic void quickSort(E[] array) {\n// ...\n}\n\npublic boolean isSorted(E[] array) {\n// ...\n}\n}\n</code></pre>"},{"location":"2023%20SS/06%20Generizit%C3%A4t/%C3%9Cbergabe-%20und%20R%C3%BCckgabeparameter/","title":"\u00dcbergabe- und R\u00fcckgabeparameter","text":"<p>In Programmieren von Methoden ist es m\u00f6glich, beliebig viele Parameter in der Signatur anzugeben. Ab einer gewissen Anzahl von Parametern in einer Methode wird das allerdings un\u00fcbersichtlich und f\u00fchrt zu unleserlichem Code. Die folgende Methode nimmt zum Beispiel 5 unterschiedliche Parameter an.</p> <pre><code>public void createPerson(String firstName, String lastName, int age, int height, String eyeColor) {\n// ...\n}\n</code></pre> <p>Um den Code \u00fcbersichtlich zu halten, wird es empfohlen, statt einer gro\u00dfen Anzahl von primitiven Parametern nur einen einzigen abstrakten Datentyp als Parameter in die Signatur zu schreiben.</p> <pre><code>class PersonDetails {\nString firstName;\nString lastName;\nint age;\nint height;\nString eyeColor;\n}\n\npublic static void createPerson(PersonDetails details) {\n// ...\n}\n</code></pre> <p>Dieses Verfahren hat neben der \u00dcbersichtlichkeit au\u00dferdem den Vorteil, dass die Parameter in einer beliebigen Reihenfolge angegeben oder sogar vollst\u00e4ndig ausgelassen werden k\u00f6nnen.</p> <pre><code>public static void main(String[] args) {\nPersonDetails detailsRoland = new PersonDetails();\n\ndetails.eyeColor = \"Brown\";\ndetails.firstName = \"Roland\";\ndetails.age = 50;\n\ncreatePerson(detailsRoland);\n}\n</code></pre> <p>Dieses Konzept ist auch f\u00fcr den R\u00fcckgabewert einer Methode anwendbar. Eine Methode kann nur einen einzigen R\u00fcckgabewert zur\u00fcckgeben. Falls eine Methode zum Beispiel also zwei Integer zur\u00fcckgeben will, ist es notwendig, einen abstrakten Datentyp f\u00fcr dieses Ergebnis zu erzeugen.</p> <pre><code>class Range {\nint minValue;\nint maxValue;\n}\n\n// Gibt den kleinsten und den gr\u00f6\u00dften Wert des Array \"array\" zur\u00fcck.\npublic static Range getArrayValueRange(int[] array) {\nint min = array[0];\nint max = array[0];\n\nfor (int value : array) {\nif (value &lt; min) {\nmin = value;\n} else if (value &gt; max) {\nmax = value;\n}\n}\n\nRange result = new Range();\nresult.minValue = min;\nresult.maxValue = max;\n\nreturn result;\n}\n</code></pre>"}]}